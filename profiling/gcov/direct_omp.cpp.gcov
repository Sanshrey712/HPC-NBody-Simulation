        -:    0:Source:/home/sunny/Desktop/HPC_Project/src/openmp/direct_omp.cpp
        -:    0:Graph:./CMakeFiles/nbody_gcov.dir/src/openmp/direct_omp.cpp.gcno
        -:    0:Data:./CMakeFiles/nbody_gcov.dir/src/openmp/direct_omp.cpp.gcda
        -:    0:Runs:4
        -:    1:#include "direct_omp.h"
        -:    2:#include <cmath>
        -:    3:#include <omp.h>
        -:    4:
    #####:    5:DirectNBodyOMP::DirectNBodyOMP(double G, double softening)
    #####:    6:    : G_(G), softening_(softening), softening_sq_(softening * softening),
    #####:    7:      interaction_count_(0), num_threads_(omp_get_max_threads()) {}
        -:    8:
    #####:    9:void DirectNBodyOMP::set_num_threads(int n) {
    #####:   10:  num_threads_ = n;
    #####:   11:  omp_set_num_threads(n);
    #####:   12:}
        -:   13:
    #####:   14:void DirectNBodyOMP::compute_forces(std::vector<Particle> &particles) {
    #####:   15:  int n = static_cast<int>(particles.size());
    #####:   16:  interaction_count_ = 0;
        -:   17:
        -:   18:// Reset accelerations in parallel
    #####:   19:#pragma omp parallel for schedule(static)
        -:   20:  for (int i = 0; i < n; ++i) {
        -:   21:    particles[i].reset_acceleration();
        -:   22:  }
        -:   23:
        -:   24:  // Parallel force computation
        -:   25:  // Using dynamic scheduling for load balancing (triangular loop)
    #####:   26:  long long local_interactions = 0;
        -:   27:
    #####:   28:#pragma omp parallel reduction(+ : local_interactions)
        -:   29:  {
        -:   30:    // Thread-local acceleration arrays to avoid race conditions
        -:   31:    std::vector<Vector3D> local_acc(n);
        -:   32:
        -:   33:#pragma omp for schedule(dynamic, 64)
        -:   34:    for (int i = 0; i < n; ++i) {
        -:   35:      for (int j = i + 1; j < n; ++j) {
        -:   36:        // Distance vector from i to j
        -:   37:        Vector3D r = particles[j].position - particles[i].position;
        -:   38:        double dist_sq = r.magnitude_sq() + softening_sq_;
        -:   39:        double dist = sqrt(dist_sq);
        -:   40:        double dist_cubed = dist_sq * dist;
        -:   41:
        -:   42:        double force_factor = G_ / dist_cubed;
        -:   43:
        -:   44:        Vector3D acc_i = r * (force_factor * particles[j].mass);
        -:   45:        Vector3D acc_j = r * (force_factor * particles[i].mass);
        -:   46:
        -:   47:        local_acc[i] += acc_i;
        -:   48:        local_acc[j] -= acc_j; // Newton's third law
        -:   49:
        -:   50:        local_interactions++;
        -:   51:      }
        -:   52:    }
        -:   53:
        -:   54:// Reduce local accelerations to global
        -:   55:#pragma omp critical
        -:   56:    {
        -:   57:      for (int i = 0; i < n; ++i) {
        -:   58:        particles[i].acceleration += local_acc[i];
        -:   59:      }
        -:   60:    }
        -:   61:  }
        -:   62:
    #####:   63:  interaction_count_ = local_interactions;
    #####:   64:}
        -:   65:
    #####:   66:void DirectNBodyOMP::integrate(std::vector<Particle> &particles, double dt) {
    #####:   67:  int n = static_cast<int>(particles.size());
    #####:   68:  double half_dt = 0.5 * dt;
        -:   69:
        -:   70:// Kick: update velocity by half step (parallel)
    #####:   71:#pragma omp parallel for schedule(static)
        -:   72:  for (int i = 0; i < n; ++i) {
        -:   73:    particles[i].velocity += particles[i].acceleration * half_dt;
        -:   74:    particles[i].position += particles[i].velocity * dt;
        -:   75:  }
        -:   76:
        -:   77:  // Compute new forces at updated positions
    #####:   78:  compute_forces(particles);
        -:   79:
        -:   80:// Kick: update velocity by half step (parallel)
    #####:   81:#pragma omp parallel for schedule(static)
        -:   82:  for (int i = 0; i < n; ++i) {
        -:   83:    particles[i].velocity += particles[i].acceleration * half_dt;
        -:   84:  }
    #####:   85:}
        -:   86:
    #####:   87:void DirectNBodyOMP::step(std::vector<Particle> &particles, double dt) {
    #####:   88:  integrate(particles, dt);
    #####:   89:}
        -:   90:
    #####:   91:double DirectNBodyOMP::compute_kinetic_energy(
        -:   92:    const std::vector<Particle> &particles) const {
    #####:   93:  double KE = 0.0;
    #####:   94:  int n = static_cast<int>(particles.size());
        -:   95:
    #####:   96:#pragma omp parallel for reduction(+ : KE) schedule(static)
        -:   97:  for (int i = 0; i < n; ++i) {
        -:   98:    KE += particles[i].kinetic_energy();
        -:   99:  }
        -:  100:
    #####:  101:  return KE;
        -:  102:}
        -:  103:
    #####:  104:double DirectNBodyOMP::compute_potential_energy(
        -:  105:    const std::vector<Particle> &particles) const {
    #####:  106:  double PE = 0.0;
    #####:  107:  int n = static_cast<int>(particles.size());
        -:  108:
    #####:  109:#pragma omp parallel for reduction(+ : PE) schedule(dynamic, 64)
        -:  110:  for (int i = 0; i < n; ++i) {
        -:  111:    for (int j = i + 1; j < n; ++j) {
        -:  112:      Vector3D r = particles[j].position - particles[i].position;
        -:  113:      double dist = sqrt(r.magnitude_sq() + softening_sq_);
        -:  114:      PE -= G_ * particles[i].mass * particles[j].mass / dist;
        -:  115:    }
        -:  116:  }
        -:  117:
    #####:  118:  return PE;
        -:  119:}
        -:  120:
    #####:  121:double DirectNBodyOMP::compute_total_energy(
        -:  122:    const std::vector<Particle> &particles) const {
    #####:  123:  return compute_kinetic_energy(particles) +
    #####:  124:         compute_potential_energy(particles);
        -:  125:}
