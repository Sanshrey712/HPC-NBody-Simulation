*** File /usr/include/c++/13/bits/unique_ptr.h:
                // unique_ptr implementation -*- C++ -*-
                
                // Copyright (C) 2008-2023 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/unique_ptr.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _UNIQUE_PTR_H
                #define _UNIQUE_PTR_H 1
                
                #include <bits/c++config.h>
                #include <debug/assertions.h>
                #include <type_traits>
                #include <tuple>
                #include <bits/stl_function.h>
                #include <bits/functional_hash.h>
                #if __cplusplus >= 202002L
                # include <compare>
                # if _GLIBCXX_HOSTED
                #  include <ostream>
                # endif
                #endif
                
                /* Duplicate definition with ptr_traits.h.  */
                #if __cplusplus > 202002L && defined(__cpp_constexpr_dynamic_alloc)
                # define __cpp_lib_constexpr_memory 202202L
                #elif __cplusplus > 201703L
                # define __cpp_lib_constexpr_memory 201811L
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @addtogroup pointer_abstractions
                   * @{
                   */
                
                #if _GLIBCXX_USE_DEPRECATED
                #pragma GCC diagnostic push
                #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
                  template<typename> class auto_ptr;
                #pragma GCC diagnostic pop
                #endif
                
                  /** Primary template of default_delete, used by unique_ptr for single objects
                   *
                   * @headerfile memory
                   * @since C++11
                   */
                  template<typename _Tp>
                    struct default_delete
                    {
                      /// Default constructor
                      constexpr default_delete() noexcept = default;
                
                      /** @brief Converting constructor.
                       *
                       * Allows conversion from a deleter for objects of another type, `_Up`,
                       * only if `_Up*` is convertible to `_Tp*`.
                       */
                      template<typename _Up,
                	       typename = _Require<is_convertible<_Up*, _Tp*>>>
                	_GLIBCXX23_CONSTEXPR
                        default_delete(const default_delete<_Up>&) noexcept { }
                
                      /// Calls `delete __ptr`
                      _GLIBCXX23_CONSTEXPR
                      void
                      operator()(_Tp* __ptr) const
                      {
                	static_assert(!is_void<_Tp>::value,
                		      "can't delete pointer to incomplete type");
                	static_assert(sizeof(_Tp)>0,
                		      "can't delete pointer to incomplete type");
                	delete __ptr;
                      }
                    };
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 740 - omit specialization for array objects with a compile time length
                
                  /** Specialization of default_delete for arrays, used by `unique_ptr<T[]>`
                   *
                   * @headerfile memory
                   * @since C++11
                   */
                  template<typename _Tp>
                    struct default_delete<_Tp[]>
                    {
                    public:
                      /// Default constructor
                      constexpr default_delete() noexcept = default;
                
                      /** @brief Converting constructor.
                       *
                       * Allows conversion from a deleter for arrays of another type, such as
                       * a const-qualified version of `_Tp`.
                       *
                       * Conversions from types derived from `_Tp` are not allowed because
                       * it is undefined to `delete[]` an array of derived types through a
                       * pointer to the base type.
                       */
                      template<typename _Up,
                	       typename = _Require<is_convertible<_Up(*)[], _Tp(*)[]>>>
                	_GLIBCXX23_CONSTEXPR
                        default_delete(const default_delete<_Up[]>&) noexcept { }
                
                      /// Calls `delete[] __ptr`
                      template<typename _Up>
                	_GLIBCXX23_CONSTEXPR
                	typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
                	operator()(_Up* __ptr) const
                	{
                	  static_assert(sizeof(_Tp)>0,
                			"can't delete pointer to incomplete type");
                	  delete [] __ptr;
                	}
                    };
                
                  /// @cond undocumented
                
                  // Manages the pointer and deleter of a unique_ptr
                  template <typename _Tp, typename _Dp>
                    class __uniq_ptr_impl
                    {
                      template <typename _Up, typename _Ep, typename = void>
                	struct _Ptr
                	{
                	  using type = _Up*;
                	};
                
                      template <typename _Up, typename _Ep>
                	struct
                	_Ptr<_Up, _Ep, __void_t<typename remove_reference<_Ep>::type::pointer>>
                	{
                	  using type = typename remove_reference<_Ep>::type::pointer;
                	};
                
                    public:
                      using _DeleterConstraint = enable_if<
                        __and_<__not_<is_pointer<_Dp>>,
                	       is_default_constructible<_Dp>>::value>;
                
                      using pointer = typename _Ptr<_Tp, _Dp>::type;
                
                      static_assert( !is_rvalue_reference<_Dp>::value,
                		     "unique_ptr's deleter type must be a function object type"
                		     " or an lvalue reference type" );
                
                      __uniq_ptr_impl() = default;
                      _GLIBCXX23_CONSTEXPR
                      __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }
                
                      template<typename _Del>
                	_GLIBCXX23_CONSTEXPR
                	__uniq_ptr_impl(pointer __p, _Del&& __d)
                	: _M_t(__p, std::forward<_Del>(__d)) { }
                
                      _GLIBCXX23_CONSTEXPR
                      __uniq_ptr_impl(__uniq_ptr_impl&& __u) noexcept
                      : _M_t(std::move(__u._M_t))
                      { __u._M_ptr() = nullptr; }
                
                      _GLIBCXX23_CONSTEXPR
                      __uniq_ptr_impl& operator=(__uniq_ptr_impl&& __u) noexcept
                      {
                	reset(__u.release());
                	_M_deleter() = std::forward<_Dp>(__u._M_deleter());
                	return *this;
                      }
                
                      _GLIBCXX23_CONSTEXPR
                      pointer&   _M_ptr() noexcept { return std::get<0>(_M_t); }
                      _GLIBCXX23_CONSTEXPR
                      pointer    _M_ptr() const noexcept { return std::get<0>(_M_t); }
                      _GLIBCXX23_CONSTEXPR
                      _Dp&       _M_deleter() noexcept { return std::get<1>(_M_t); }
                      _GLIBCXX23_CONSTEXPR
                      const _Dp& _M_deleter() const noexcept { return std::get<1>(_M_t); }
                
                      _GLIBCXX23_CONSTEXPR
                      void reset(pointer __p) noexcept
                      {
                	const pointer __old_p = _M_ptr();
                	_M_ptr() = __p;
                	if (__old_p)
                	  _M_deleter()(__old_p);
                      }
                
                      _GLIBCXX23_CONSTEXPR
                      pointer release() noexcept
                      {
                	pointer __p = _M_ptr();
                	_M_ptr() = nullptr;
                	return __p;
                      }
                
                      _GLIBCXX23_CONSTEXPR
                      void
                      swap(__uniq_ptr_impl& __rhs) noexcept
                      {
                	using std::swap;
                	swap(this->_M_ptr(), __rhs._M_ptr());
                	swap(this->_M_deleter(), __rhs._M_deleter());
                      }
                
                    private:
                      tuple<pointer, _Dp> _M_t;
                    };
                
                  // Defines move construction + assignment as either defaulted or deleted.
                  template <typename _Tp, typename _Dp,
                	    bool = is_move_constructible<_Dp>::value,
                	    bool = is_move_assignable<_Dp>::value>
                    struct __uniq_ptr_data : __uniq_ptr_impl<_Tp, _Dp>
                    {
                      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
                      __uniq_ptr_data(__uniq_ptr_data&&) = default;
                      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
                    };
                
                  template <typename _Tp, typename _Dp>
                    struct __uniq_ptr_data<_Tp, _Dp, true, false> : __uniq_ptr_impl<_Tp, _Dp>
                    {
                      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
                      __uniq_ptr_data(__uniq_ptr_data&&) = default;
                      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = delete;
                    };
                
                  template <typename _Tp, typename _Dp>
                    struct __uniq_ptr_data<_Tp, _Dp, false, true> : __uniq_ptr_impl<_Tp, _Dp>
                    {
                      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
                      __uniq_ptr_data(__uniq_ptr_data&&) = delete;
                      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
                    };
                
                  template <typename _Tp, typename _Dp>
                    struct __uniq_ptr_data<_Tp, _Dp, false, false> : __uniq_ptr_impl<_Tp, _Dp>
                    {
                      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
                      __uniq_ptr_data(__uniq_ptr_data&&) = delete;
                      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = delete;
                    };
                  /// @endcond
                
                  // 20.7.1.2 unique_ptr for single objects.
                
                  /// A move-only smart pointer that manages unique ownership of a resource.
                  /// @headerfile memory
                  /// @since C++11
                  template <typename _Tp, typename _Dp = default_delete<_Tp>>
                    class unique_ptr
                    {
                      template <typename _Up>
                	using _DeleterConstraint =
                	  typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;
                
                      __uniq_ptr_data<_Tp, _Dp> _M_t;
                
                    public:
                      using pointer	  = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
                      using element_type  = _Tp;
                      using deleter_type  = _Dp;
                
                    private:
                      // helper template for detecting a safe conversion from another
                      // unique_ptr
                      template<typename _Up, typename _Ep>
                	using __safe_conversion_up = __and_<
                	  is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
                	  __not_<is_array<_Up>>
                        >;
                
                    public:
                      // Constructors.
                
                      /// Default constructor, creates a unique_ptr that owns nothing.
                      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
                	constexpr unique_ptr() noexcept
                	: _M_t()
                	{ }
                
                      /** Takes ownership of a pointer.
                       *
                       * @param __p  A pointer to an object of @c element_type
                       *
                       * The deleter will be value-initialized.
                       */
                      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
                	_GLIBCXX23_CONSTEXPR
                	explicit
                	unique_ptr(pointer __p) noexcept
                	: _M_t(__p)
                        { }
                
                      /** Takes ownership of a pointer.
                       *
                       * @param __p  A pointer to an object of @c element_type
                       * @param __d  A reference to a deleter.
                       *
                       * The deleter will be initialized with @p __d
                       */
                      template<typename _Del = deleter_type,
                	       typename = _Require<is_copy_constructible<_Del>>>
                	_GLIBCXX23_CONSTEXPR
                	unique_ptr(pointer __p, const deleter_type& __d) noexcept
                	: _M_t(__p, __d) { }
                
                      /** Takes ownership of a pointer.
                       *
                       * @param __p  A pointer to an object of @c element_type
                       * @param __d  An rvalue reference to a (non-reference) deleter.
                       *
                       * The deleter will be initialized with @p std::move(__d)
                       */
                      template<typename _Del = deleter_type,
                	       typename = _Require<is_move_constructible<_Del>>>
                	_GLIBCXX23_CONSTEXPR
                	unique_ptr(pointer __p,
                		   __enable_if_t<!is_lvalue_reference<_Del>::value,
                				 _Del&&> __d) noexcept
                	: _M_t(__p, std::move(__d))
                	{ }
                
                      template<typename _Del = deleter_type,
                	       typename _DelUnref = typename remove_reference<_Del>::type>
                	_GLIBCXX23_CONSTEXPR
                	unique_ptr(pointer,
                		   __enable_if_t<is_lvalue_reference<_Del>::value,
                				 _DelUnref&&>) = delete;
                
                      /// Creates a unique_ptr that owns nothing.
                      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
                	constexpr unique_ptr(nullptr_t) noexcept
                	: _M_t()
                	{ }
                
                      // Move constructors.
                
                      /// Move constructor.
                      unique_ptr(unique_ptr&&) = default;
                
                      /** @brief Converting constructor from another type
                       *
                       * Requires that the pointer owned by @p __u is convertible to the
                       * type of pointer owned by this object, @p __u does not own an array,
                       * and @p __u has a compatible deleter type.
                       */
                      template<typename _Up, typename _Ep, typename = _Require<
                               __safe_conversion_up<_Up, _Ep>,
                	       __conditional_t<is_reference<_Dp>::value,
                			       is_same<_Ep, _Dp>,
                			       is_convertible<_Ep, _Dp>>>>
                	_GLIBCXX23_CONSTEXPR
                	unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
                	: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
                	{ }
                
                #if _GLIBCXX_USE_DEPRECATED
                #pragma GCC diagnostic push
                #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
                      /// Converting constructor from @c auto_ptr
                      template<typename _Up, typename = _Require<
                	       is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
                	unique_ptr(auto_ptr<_Up>&& __u) noexcept;
                #pragma GCC diagnostic pop
                #endif
                
                      /// Destructor, invokes the deleter if the stored pointer is not null.
                #if __cplusplus > 202002L && __cpp_constexpr_dynamic_alloc
                      constexpr
                #endif
         256 ->       ~unique_ptr() noexcept
                      {
                	static_assert(__is_invocable<deleter_type&, pointer>::value,
                		      "unique_ptr's deleter must be invocable with a pointer");
                	auto& __ptr = _M_t._M_ptr();
                	if (__ptr != nullptr)
                	  get_deleter()(std::move(__ptr));
                	__ptr = pointer();
                      }
                
                      // Assignment.
                
                      /** @brief Move assignment operator.
                       *
                       * Invokes the deleter if this object owns a pointer.
                       */
                      unique_ptr& operator=(unique_ptr&&) = default;
                
                      /** @brief Assignment from another type.
                       *
                       * @param __u  The object to transfer ownership from, which owns a
                       *             convertible pointer to a non-array object.
                       *
                       * Invokes the deleter if this object owns a pointer.
                       */
                      template<typename _Up, typename _Ep>
                	_GLIBCXX23_CONSTEXPR
                        typename enable_if< __and_<
                          __safe_conversion_up<_Up, _Ep>,
                          is_assignable<deleter_type&, _Ep&&>
                          >::value,
                          unique_ptr&>::type
                	operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
                	{
                	  reset(__u.release());
                	  get_deleter() = std::forward<_Ep>(__u.get_deleter());
                	  return *this;
                	}
                
                      /// Reset the %unique_ptr to empty, invoking the deleter if necessary.
                      _GLIBCXX23_CONSTEXPR
                      unique_ptr&
                      operator=(nullptr_t) noexcept
                      {
                	reset();
                	return *this;
                      }
                
                      // Observers.
                
                      /// Dereference the stored pointer.
                      _GLIBCXX23_CONSTEXPR
                      typename add_lvalue_reference<element_type>::type
                      operator*() const noexcept(noexcept(*std::declval<pointer>()))
                      {
                	__glibcxx_assert(get() != pointer());
                	return *get();
                      }
                
                      /// Return the stored pointer.
                      _GLIBCXX23_CONSTEXPR
                      pointer
                      operator->() const noexcept
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(get() != pointer());
                	return get();
                      }
                
                      /// Return the stored pointer.
                      _GLIBCXX23_CONSTEXPR
                      pointer
                      get() const noexcept
                      { return _M_t._M_ptr(); }
                
                      /// Return a reference to the stored deleter.
                      _GLIBCXX23_CONSTEXPR
                      deleter_type&
                      get_deleter() noexcept
                      { return _M_t._M_deleter(); }
                
                      /// Return a reference to the stored deleter.
                      _GLIBCXX23_CONSTEXPR
                      const deleter_type&
                      get_deleter() const noexcept
                      { return _M_t._M_deleter(); }
                
                      /// Return @c true if the stored pointer is not null.
                      _GLIBCXX23_CONSTEXPR
                      explicit operator bool() const noexcept
                      { return get() == pointer() ? false : true; }
                
                      // Modifiers.
                
                      /// Release ownership of any stored pointer.
                      _GLIBCXX23_CONSTEXPR
                      pointer
                      release() noexcept
                      { return _M_t.release(); }
                
                      /** @brief Replace the stored pointer.
                       *
                       * @param __p  The new pointer to store.
                       *
                       * The deleter will be invoked if a pointer is already owned.
                       */
                      _GLIBCXX23_CONSTEXPR
                      void
                      reset(pointer __p = pointer()) noexcept
                      {
                	static_assert(__is_invocable<deleter_type&, pointer>::value,
                		      "unique_ptr's deleter must be invocable with a pointer");
                	_M_t.reset(std::move(__p));
                      }
                
                      /// Exchange the pointer and deleter with another object.
                      _GLIBCXX23_CONSTEXPR
                      void
                      swap(unique_ptr& __u) noexcept
                      {
                	static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
                	_M_t.swap(__u._M_t);
                      }
                
                      // Disable copy from lvalue.
                      unique_ptr(const unique_ptr&) = delete;
                      unique_ptr& operator=(const unique_ptr&) = delete;
                  };
                
                  // 20.7.1.3 unique_ptr for array objects with a runtime length
                  // [unique.ptr.runtime]
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 740 - omit specialization for array objects with a compile time length
                
                  /// A move-only smart pointer that manages unique ownership of an array.
                  /// @headerfile memory
                  /// @since C++11
                  template<typename _Tp, typename _Dp>
                    class unique_ptr<_Tp[], _Dp>
                    {
                      template <typename _Up>
                      using _DeleterConstraint =
                	typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;
                
                      __uniq_ptr_data<_Tp, _Dp> _M_t;
                
                      // like is_base_of<_Tp, _Up> but false if unqualified types are the same
                      template<typename _Up>
                	using __is_derived_Tp
                	  = __and_< is_base_of<_Tp, _Up>,
                		    __not_<is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up>>> >;
                
                    public:
                      using pointer	  = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
                      using element_type  = _Tp;
                      using deleter_type  = _Dp;
                
                      // helper template for detecting a safe conversion from another
                      // unique_ptr
                      template<typename _Up, typename _Ep,
                               typename _UPtr = unique_ptr<_Up, _Ep>,
                	       typename _UP_pointer = typename _UPtr::pointer,
                	       typename _UP_element_type = typename _UPtr::element_type>
                	using __safe_conversion_up = __and_<
                          is_array<_Up>,
                          is_same<pointer, element_type*>,
                          is_same<_UP_pointer, _UP_element_type*>,
                          is_convertible<_UP_element_type(*)[], element_type(*)[]>
                        >;
                
                      // helper template for detecting a safe conversion from a raw pointer
                      template<typename _Up>
                        using __safe_conversion_raw = __and_<
                          __or_<__or_<is_same<_Up, pointer>,
                                      is_same<_Up, nullptr_t>>,
                                __and_<is_pointer<_Up>,
                                       is_same<pointer, element_type*>,
                                       is_convertible<
                                         typename remove_pointer<_Up>::type(*)[],
                                         element_type(*)[]>
                                >
                          >
                        >;
                
                      // Constructors.
                
                      /// Default constructor, creates a unique_ptr that owns nothing.
                      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
                	constexpr unique_ptr() noexcept
                	: _M_t()
                	{ }
                
                      /** Takes ownership of a pointer.
                       *
                       * @param __p  A pointer to an array of a type safely convertible
                       * to an array of @c element_type
                       *
                       * The deleter will be value-initialized.
                       */
                      template<typename _Up,
                	       typename _Vp = _Dp,
                	       typename = _DeleterConstraint<_Vp>,
                	       typename = typename enable_if<
                                 __safe_conversion_raw<_Up>::value, bool>::type>
                	_GLIBCXX23_CONSTEXPR
                	explicit
                	unique_ptr(_Up __p) noexcept
                	: _M_t(__p)
                        { }
                
                      /** Takes ownership of a pointer.
                       *
                       * @param __p  A pointer to an array of a type safely convertible
                       * to an array of @c element_type
                       * @param __d  A reference to a deleter.
                       *
                       * The deleter will be initialized with @p __d
                       */
                      template<typename _Up, typename _Del = deleter_type,
                	       typename = _Require<__safe_conversion_raw<_Up>,
                				   is_copy_constructible<_Del>>>
                	_GLIBCXX23_CONSTEXPR
                	unique_ptr(_Up __p, const deleter_type& __d) noexcept
                	: _M_t(__p, __d) { }
                
                      /** Takes ownership of a pointer.
                       *
                       * @param __p  A pointer to an array of a type safely convertible
                       * to an array of @c element_type
                       * @param __d  A reference to a deleter.
                       *
                       * The deleter will be initialized with @p std::move(__d)
                       */
                      template<typename _Up, typename _Del = deleter_type,
                	       typename = _Require<__safe_conversion_raw<_Up>,
                				   is_move_constructible<_Del>>>
                	_GLIBCXX23_CONSTEXPR
                	unique_ptr(_Up __p,
                		   __enable_if_t<!is_lvalue_reference<_Del>::value,
                				 _Del&&> __d) noexcept
                	: _M_t(std::move(__p), std::move(__d))
                	{ }
                
                      template<typename _Up, typename _Del = deleter_type,
                	       typename _DelUnref = typename remove_reference<_Del>::type,
                	       typename = _Require<__safe_conversion_raw<_Up>>>
                	unique_ptr(_Up,
                		   __enable_if_t<is_lvalue_reference<_Del>::value,
                				 _DelUnref&&>) = delete;
                
                      /// Move constructor.
                      unique_ptr(unique_ptr&&) = default;
                
                      /// Creates a unique_ptr that owns nothing.
                      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
                	constexpr unique_ptr(nullptr_t) noexcept
                	: _M_t()
                        { }
                
                      template<typename _Up, typename _Ep, typename = _Require<
                	       __safe_conversion_up<_Up, _Ep>,
                	       __conditional_t<is_reference<_Dp>::value,
                			       is_same<_Ep, _Dp>,
                			       is_convertible<_Ep, _Dp>>>>
                	_GLIBCXX23_CONSTEXPR
                	unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
                	: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
                	{ }
                
                      /// Destructor, invokes the deleter if the stored pointer is not null.
                #if __cplusplus > 202002L && __cpp_constexpr_dynamic_alloc
                      constexpr
                #endif
                      ~unique_ptr()
                      {
                	auto& __ptr = _M_t._M_ptr();
                	if (__ptr != nullptr)
                	  get_deleter()(__ptr);
                	__ptr = pointer();
                      }
                
                      // Assignment.
                
                      /** @brief Move assignment operator.
                       *
                       * Invokes the deleter if this object owns a pointer.
                       */
                      unique_ptr&
                      operator=(unique_ptr&&) = default;
                
                      /** @brief Assignment from another type.
                       *
                       * @param __u  The object to transfer ownership from, which owns a
                       *             convertible pointer to an array object.
                       *
                       * Invokes the deleter if this object owns a pointer.
                       */
                      template<typename _Up, typename _Ep>
                	_GLIBCXX23_CONSTEXPR
                	typename
                	enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                                         is_assignable<deleter_type&, _Ep&&>
                                  >::value,
                                  unique_ptr&>::type
                	operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
                	{
                	  reset(__u.release());
                	  get_deleter() = std::forward<_Ep>(__u.get_deleter());
                	  return *this;
                	}
                
                      /// Reset the %unique_ptr to empty, invoking the deleter if necessary.
                      _GLIBCXX23_CONSTEXPR
                      unique_ptr&
                      operator=(nullptr_t) noexcept
                      {
                	reset();
                	return *this;
                      }
                
                      // Observers.
                
                      /// Access an element of owned array.
                      _GLIBCXX23_CONSTEXPR
                      typename std::add_lvalue_reference<element_type>::type
                      operator[](size_t __i) const
                      {
                	__glibcxx_assert(get() != pointer());
                	return get()[__i];
                      }
                
                      /// Return the stored pointer.
                      _GLIBCXX23_CONSTEXPR
                      pointer
                      get() const noexcept
                      { return _M_t._M_ptr(); }
                
                      /// Return a reference to the stored deleter.
                      _GLIBCXX23_CONSTEXPR
                      deleter_type&
                      get_deleter() noexcept
                      { return _M_t._M_deleter(); }
                
                      /// Return a reference to the stored deleter.
                      _GLIBCXX23_CONSTEXPR
                      const deleter_type&
                      get_deleter() const noexcept
                      { return _M_t._M_deleter(); }
                
                      /// Return @c true if the stored pointer is not null.
                      _GLIBCXX23_CONSTEXPR
                      explicit operator bool() const noexcept
                      { return get() == pointer() ? false : true; }
                
                      // Modifiers.
                
                      /// Release ownership of any stored pointer.
                      _GLIBCXX23_CONSTEXPR
                      pointer
                      release() noexcept
                      { return _M_t.release(); }
                
                      /** @brief Replace the stored pointer.
                       *
                       * @param __p  The new pointer to store.
                       *
                       * The deleter will be invoked if a pointer is already owned.
                       */
                      template <typename _Up,
                                typename = _Require<
                                  __or_<is_same<_Up, pointer>,
                                        __and_<is_same<pointer, element_type*>,
                                               is_pointer<_Up>,
                                               is_convertible<
                                                 typename remove_pointer<_Up>::type(*)[],
                                                 element_type(*)[]
                                               >
                                        >
                                  >
                               >>
                      _GLIBCXX23_CONSTEXPR
                      void
                      reset(_Up __p) noexcept
                      { _M_t.reset(std::move(__p)); }
                
                      _GLIBCXX23_CONSTEXPR
                      void reset(nullptr_t = nullptr) noexcept
                      { reset(pointer()); }
                
                      /// Exchange the pointer and deleter with another object.
                      _GLIBCXX23_CONSTEXPR
                      void
                      swap(unique_ptr& __u) noexcept
                      {
                	static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
                	_M_t.swap(__u._M_t);
                      }
                
                      // Disable copy from lvalue.
                      unique_ptr(const unique_ptr&) = delete;
                      unique_ptr& operator=(const unique_ptr&) = delete;
                    };
                
                  /// @{
                  /// @relates unique_ptr
                
                  /// Swap overload for unique_ptr
                  template<typename _Tp, typename _Dp>
                    inline
                #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
                    // Constrained free swap overload, see p0185r1
                    _GLIBCXX23_CONSTEXPR
                    typename enable_if<__is_swappable<_Dp>::value>::type
                #else
                    void
                #endif
                    swap(unique_ptr<_Tp, _Dp>& __x,
                	 unique_ptr<_Tp, _Dp>& __y) noexcept
                    { __x.swap(__y); }
                
                #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
                  template<typename _Tp, typename _Dp>
                    typename enable_if<!__is_swappable<_Dp>::value>::type
                    swap(unique_ptr<_Tp, _Dp>&,
                	 unique_ptr<_Tp, _Dp>&) = delete;
                #endif
                
                  /// Equality operator for unique_ptr objects, compares the owned pointers
                  template<typename _Tp, typename _Dp,
                	   typename _Up, typename _Ep>
                    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
                    inline bool
                    operator==(const unique_ptr<_Tp, _Dp>& __x,
                	       const unique_ptr<_Up, _Ep>& __y)
                    { return __x.get() == __y.get(); }
                
                  /// unique_ptr comparison with nullptr
                  template<typename _Tp, typename _Dp>
                    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
                    inline bool
                    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
                    { return !__x; }
                
                #ifndef __cpp_lib_three_way_comparison
                  /// unique_ptr comparison with nullptr
                  template<typename _Tp, typename _Dp>
                    _GLIBCXX_NODISCARD
                    inline bool
                    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
                    { return !__x; }
                
                  /// Inequality operator for unique_ptr objects, compares the owned pointers
                  template<typename _Tp, typename _Dp,
                	   typename _Up, typename _Ep>
                    _GLIBCXX_NODISCARD
                    inline bool
                    operator!=(const unique_ptr<_Tp, _Dp>& __x,
                	       const unique_ptr<_Up, _Ep>& __y)
                    { return __x.get() != __y.get(); }
                
                  /// unique_ptr comparison with nullptr
                  template<typename _Tp, typename _Dp>
                    _GLIBCXX_NODISCARD
                    inline bool
                    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
                    { return (bool)__x; }
                
                  /// unique_ptr comparison with nullptr
                  template<typename _Tp, typename _Dp>
                    _GLIBCXX_NODISCARD
                    inline bool
                    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
                    { return (bool)__x; }
                #endif // three way comparison
                
                  /// Relational operator for unique_ptr objects, compares the owned pointers
                  template<typename _Tp, typename _Dp,
                	   typename _Up, typename _Ep>
                    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
                    inline bool
                    operator<(const unique_ptr<_Tp, _Dp>& __x,
                	      const unique_ptr<_Up, _Ep>& __y)
                    {
                      typedef typename
                	std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                	                 typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
                      return std::less<_CT>()(__x.get(), __y.get());
                    }
                
                  /// unique_ptr comparison with nullptr
                  template<typename _Tp, typename _Dp>
                    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
                    inline bool
                    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
                    {
                      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
                								 nullptr);
                    }
                
                  /// unique_ptr comparison with nullptr
                  template<typename _Tp, typename _Dp>
                    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
                    inline bool
                    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
                    {
                      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
                								 __x.get());
                    }
                
                  /// Relational operator for unique_ptr objects, compares the owned pointers
                  template<typename _Tp, typename _Dp,
                	   typename _Up, typename _Ep>
                    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
                    inline bool
                    operator<=(const unique_ptr<_Tp, _Dp>& __x,
                	       const unique_ptr<_Up, _Ep>& __y)
                    { return !(__y < __x); }
                
                  /// unique_ptr comparison with nullptr
                  template<typename _Tp, typename _Dp>
                    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
                    inline bool
                    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
                    { return !(nullptr < __x); }
                
                  /// unique_ptr comparison with nullptr
                  template<typename _Tp, typename _Dp>
                    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
                    inline bool
                    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
                    { return !(__x < nullptr); }
                
                  /// Relational operator for unique_ptr objects, compares the owned pointers
                  template<typename _Tp, typename _Dp,
                	   typename _Up, typename _Ep>
                    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
                    inline bool
                    operator>(const unique_ptr<_Tp, _Dp>& __x,
                	      const unique_ptr<_Up, _Ep>& __y)
                    { return (__y < __x); }
                
                  /// unique_ptr comparison with nullptr
                  template<typename _Tp, typename _Dp>
                    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
                    inline bool
                    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
                    {
                      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
                								 __x.get());
                    }
                
                  /// unique_ptr comparison with nullptr
                  template<typename _Tp, typename _Dp>
                    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
                    inline bool
                    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
                    {
                      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
                								 nullptr);
                    }
                
                  /// Relational operator for unique_ptr objects, compares the owned pointers
                  template<typename _Tp, typename _Dp,
                	   typename _Up, typename _Ep>
                    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
                    inline bool
                    operator>=(const unique_ptr<_Tp, _Dp>& __x,
                	       const unique_ptr<_Up, _Ep>& __y)
                    { return !(__x < __y); }
                
                  /// unique_ptr comparison with nullptr
                  template<typename _Tp, typename _Dp>
                    _GLIBCXX_NODISCARD _GLIBCXX23_CONSTEXPR
                    inline bool
                    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
                    { return !(__x < nullptr); }
                
                  /// unique_ptr comparison with nullptr
                  template<typename _Tp, typename _Dp>
                    _GLIBCXX_NODISCARD inline bool
                    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
                    { return !(nullptr < __x); }
                
                #ifdef __cpp_lib_three_way_comparison
                  template<typename _Tp, typename _Dp, typename _Up, typename _Ep>
                    requires three_way_comparable_with<typename unique_ptr<_Tp, _Dp>::pointer,
                				       typename unique_ptr<_Up, _Ep>::pointer>
                    _GLIBCXX23_CONSTEXPR
                    inline
                    compare_three_way_result_t<typename unique_ptr<_Tp, _Dp>::pointer,
                			       typename unique_ptr<_Up, _Ep>::pointer>
                    operator<=>(const unique_ptr<_Tp, _Dp>& __x,
                		const unique_ptr<_Up, _Ep>& __y)
                    { return compare_three_way()(__x.get(), __y.get()); }
                
                  template<typename _Tp, typename _Dp>
                    requires three_way_comparable<typename unique_ptr<_Tp, _Dp>::pointer>
                    _GLIBCXX23_CONSTEXPR
                    inline
                    compare_three_way_result_t<typename unique_ptr<_Tp, _Dp>::pointer>
                    operator<=>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
                    {
                      using pointer = typename unique_ptr<_Tp, _Dp>::pointer;
                      return compare_three_way()(__x.get(), static_cast<pointer>(nullptr));
                    }
                #endif
                  /// @} relates unique_ptr
                
                  /// @cond undocumented
                  template<typename _Up, typename _Ptr = typename _Up::pointer,
                	   bool = __poison_hash<_Ptr>::__enable_hash_call>
                    struct __uniq_ptr_hash
                #if ! _GLIBCXX_INLINE_VERSION
                    : private __poison_hash<_Ptr>
                #endif
                    {
                      size_t
                      operator()(const _Up& __u) const
                      noexcept(noexcept(std::declval<hash<_Ptr>>()(std::declval<_Ptr>())))
                      { return hash<_Ptr>()(__u.get()); }
                    };
                
                  template<typename _Up, typename _Ptr>
                    struct __uniq_ptr_hash<_Up, _Ptr, false>
                    : private __poison_hash<_Ptr>
                    { };
                  /// @endcond
                
                  /// std::hash specialization for unique_ptr.
                  template<typename _Tp, typename _Dp>
                    struct hash<unique_ptr<_Tp, _Dp>>
                    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,
                      public __uniq_ptr_hash<unique_ptr<_Tp, _Dp>>
                    { };
                
                #if __cplusplus >= 201402L && _GLIBCXX_HOSTED
                #define __cpp_lib_make_unique 201304L
                
                  /// @cond undocumented
                namespace __detail
                {
                  template<typename _Tp>
                    struct _MakeUniq
                    { typedef unique_ptr<_Tp> __single_object; };
                
                  template<typename _Tp>
                    struct _MakeUniq<_Tp[]>
                    { typedef unique_ptr<_Tp[]> __array; };
                
                  template<typename _Tp, size_t _Bound>
                    struct _MakeUniq<_Tp[_Bound]>
                    { struct __invalid_type { }; };
                
                  template<typename _Tp>
                    using __unique_ptr_t = typename _MakeUniq<_Tp>::__single_object;
                  template<typename _Tp>
                    using __unique_ptr_array_t = typename _MakeUniq<_Tp>::__array;
                  template<typename _Tp>
                    using __invalid_make_unique_t = typename _MakeUniq<_Tp>::__invalid_type;
                }
                  /// @endcond
                
                  /** Create an object owned by a `unique_ptr`.
                   *  @tparam _Tp A non-array object type.
                   *  @param __args Constructor arguments for the new object.
                   *  @returns A `unique_ptr<_Tp>` that owns the new object.
                   *  @since C++14
                   *  @relates unique_ptr
                   */
                  template<typename _Tp, typename... _Args>
                    _GLIBCXX23_CONSTEXPR
                    inline __detail::__unique_ptr_t<_Tp>
                    make_unique(_Args&&... __args)
                    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }
                
                  /** Create an array owned by a `unique_ptr`.
                   *  @tparam _Tp An array type of unknown bound, such as `U[]`.
                   *  @param __num The number of elements of type `U` in the new array.
                   *  @returns A `unique_ptr<U[]>` that owns the new array.
                   *  @since C++14
                   *  @relates unique_ptr
                   *
                   *  The array elements are value-initialized.
                   */
                  template<typename _Tp>
                    _GLIBCXX23_CONSTEXPR
                    inline __detail::__unique_ptr_array_t<_Tp>
                    make_unique(size_t __num)
                    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }
                
                  /** Disable std::make_unique for arrays of known bound.
                   *  @tparam _Tp An array type of known bound, such as `U[N]`.
                   *  @since C++14
                   *  @relates unique_ptr
                   */
                  template<typename _Tp, typename... _Args>
                    __detail::__invalid_make_unique_t<_Tp>
                    make_unique(_Args&&...) = delete;
                
                #if __cplusplus > 201703L
                  /** Create a default-initialied object owned by a `unique_ptr`.
                   *  @tparam _Tp A non-array object type.
                   *  @returns A `unique_ptr<_Tp>` that owns the new object.
                   *  @since C++20
                   *  @relates unique_ptr
                   */
                  template<typename _Tp>
                    _GLIBCXX23_CONSTEXPR
                    inline __detail::__unique_ptr_t<_Tp>
                    make_unique_for_overwrite()
                    { return unique_ptr<_Tp>(new _Tp); }
                
                  /** Create a default-initialized array owned by a `unique_ptr`.
                   *  @tparam _Tp An array type of unknown bound, such as `U[]`.
                   *  @param __num The number of elements of type `U` in the new array.
                   *  @returns A `unique_ptr<U[]>` that owns the new array.
                   *  @since C++20
                   *  @relates unique_ptr
                   */
                  template<typename _Tp>
                    _GLIBCXX23_CONSTEXPR
                    inline __detail::__unique_ptr_array_t<_Tp>
                    make_unique_for_overwrite(size_t __num)
                    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]); }
                
                  /** Disable std::make_unique_for_overwrite for arrays of known bound.
                   *  @tparam _Tp An array type of known bound, such as `U[N]`.
                   *  @since C++20
                   *  @relates unique_ptr
                   */
                  template<typename _Tp, typename... _Args>
                    __detail::__invalid_make_unique_t<_Tp>
                    make_unique_for_overwrite(_Args&&...) = delete;
                #endif // C++20
                
                #endif // C++14 && HOSTED
                
                #if __cplusplus > 201703L && __cpp_concepts && _GLIBCXX_HOSTED
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2948. unique_ptr does not define operator<< for stream output
                  /// Stream output operator for unique_ptr
                  /// @relates unique_ptr
                  /// @since C++20
                  template<typename _CharT, typename _Traits, typename _Tp, typename _Dp>
                    inline basic_ostream<_CharT, _Traits>&
                    operator<<(basic_ostream<_CharT, _Traits>& __os,
                	       const unique_ptr<_Tp, _Dp>& __p)
                    requires requires { __os << __p.get(); }
                    {
                      __os << __p.get();
                      return __os;
                    }
                #endif // C++20 && HOSTED
                
                  /// @} group pointer_abstractions
                
                #if __cplusplus >= 201703L
                  namespace __detail::__variant
                  {
                    template<typename> struct _Never_valueless_alt; // see <variant>
                
                    // Provide the strong exception-safety guarantee when emplacing a
                    // unique_ptr into a variant.
                    template<typename _Tp, typename _Del>
                      struct _Never_valueless_alt<std::unique_ptr<_Tp, _Del>>
                      : std::true_type
                      { };
                  }  // namespace __detail::__variant
                #endif // C++17
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _UNIQUE_PTR_H */


Top 10 Lines:

     Line      Count

      398        256

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      256   Total number of line executions
   256.00   Average executions per line


*** File /home/sunny/Desktop/HPC_Project/src/main.cpp:
                #include <chrono>
                #include <cstring>
                #include <fstream>
                #include <iomanip>
                #include <iostream>
                
                // Common
                #include "common/config.h"
                #include "common/particle.h"
                
                // Serial
                #include "serial/barnes_hut.h"
                #include "serial/direct_nbody.h"
                #include "serial/generators.h"
                
                // OpenMP
                #ifdef USE_OPENMP
                #include "openmp/barnes_hut_omp.h"
                #include "openmp/direct_omp.h"
                #include <omp.h>
                #endif
                
                // MPI
                #ifdef USE_MPI
                #include "mpi/nbody_mpi.h"
                #include <mpi.h>
                #endif
                
                // CUDA
                #ifdef USE_CUDA
                #include "cuda/nbody_cuda.h"
                #endif
                
                // LIKWID
                #ifdef LIKWID_PERFMON
                #include <likwid.h>
                #endif
                
                // Output particle positions
                void output_particles(const std::vector<Particle> &particles,
       ##### ->                       const std::string &filename, int step) {
                  std::ofstream file(filename, step == 0 ? std::ios::trunc : std::ios::app);
                  file << "# Step " << step << ", N=" << particles.size() << "\n";
                  for (const auto &p : particles) {
                    file << p.position.x << " " << p.position.y << " " << p.position.z << "\n";
                  }
                  file << "\n";
                }
                
                // Generate initial conditions
           1 -> std::vector<Particle> generate_particles(const SimConfig &config) {
                  std::cout << "Generating " << config.num_particles << " particles...\n";
                  return generate_plummer(config.num_particles, config.domain_size / 4.0,
                                          config.total_mass, 42);
                }
                
                // Run serial simulation
           1 -> void run_serial(SimConfig &config) {
                  std::cout << "\n=== Serial Mode ===\n";
                
                  auto particles = generate_particles(config);
                
                  Timer timer;
                  PerfStats stats;
                
                  double initial_energy = 0.0;
                
                  if (config.use_barnes_hut) {
                    BarnesHutSolver solver(Constants::G_NORMALIZED, config.theta,
                                           config.softening);
                
                    // Initial force computation
                    solver.build_tree(particles);
                    solver.compute_forces(particles);
                
                    if (config.enable_energy_check) {
                      initial_energy = solver.compute_total_energy(particles);
                      std::cout << "Initial energy: " << initial_energy << "\n";
                    }
                
                    timer.start();
                
                    for (int step = 0; step < config.num_steps; ++step) {
                      solver.step(particles, config.timestep);
                
                      if (config.output_positions && step % config.output_interval == 0) {
                        output_particles(particles, config.output_file, step);
                      }
                
                      if (step % 10 == 0) {
                        std::cout << "\rStep " << step << "/" << config.num_steps << std::flush;
                      }
                    }
                
                    timer.stop();
                    stats.force_compute_time = timer.elapsed_ms();
                    stats.num_interactions = solver.get_interaction_count();
                
                    if (config.enable_energy_check) {
                      double final_energy = solver.compute_total_energy(particles);
                      std::cout << "\nFinal energy: " << final_energy << " (drift: "
                                << std::abs(final_energy - initial_energy) /
                                       std::abs(initial_energy) * 100
                                << "%)\n";
                    }
                  } else {
                    DirectNBody solver(Constants::G_NORMALIZED, config.softening);
                
                    solver.compute_forces(particles);
                
                    if (config.enable_energy_check) {
                      initial_energy = solver.compute_total_energy(particles);
                      std::cout << "Initial energy: " << initial_energy << "\n";
                    }
                
                    timer.start();
                
                    for (int step = 0; step < config.num_steps; ++step) {
                      solver.step(particles, config.timestep);
                
                      if (config.output_positions && step % config.output_interval == 0) {
                        output_particles(particles, config.output_file, step);
                      }
                
                      if (step % 10 == 0) {
                        std::cout << "\rStep " << step << "/" << config.num_steps << std::flush;
                      }
                    }
                
                    timer.stop();
                    stats.force_compute_time = timer.elapsed_ms();
                    stats.num_interactions = solver.get_interaction_count();
                
                    if (config.enable_energy_check) {
                      double final_energy = solver.compute_total_energy(particles);
                      std::cout << "\nFinal energy: " << final_energy << " (drift: "
                                << std::abs(final_energy - initial_energy) /
                                       std::abs(initial_energy) * 100
                                << "%)\n";
                    }
                  }
                
                  stats.total_time = stats.force_compute_time;
                  std::cout << "\n";
                  stats.print();
                }
                
                #ifdef USE_OPENMP
                // Run OpenMP simulation
       ##### -> void run_openmp(SimConfig &config) {
                  std::cout << "\n=== OpenMP Mode (" << config.num_threads << " threads) ===\n";
                  omp_set_num_threads(config.num_threads);
                
                  auto particles = generate_particles(config);
                
                  Timer timer;
                  PerfStats stats;
                
                #ifdef LIKWID_PERFMON
                  LIKWID_MARKER_INIT;
                  LIKWID_MARKER_THREADINIT;
                #endif
                
                  if (config.use_barnes_hut) {
                    BarnesHutOMP solver(Constants::G_NORMALIZED, config.theta,
                                        config.softening);
                    solver.set_num_threads(config.num_threads);
                
                    solver.build_tree(particles);
                    solver.compute_forces(particles);
                
                    timer.start();
                
                #ifdef LIKWID_PERFMON
                    LIKWID_MARKER_START("BH_FORCE_OMP");
                #endif
                
                    for (int step = 0; step < config.num_steps; ++step) {
                      solver.step(particles, config.timestep);
                
                      if (step % 10 == 0) {
                        std::cout << "\rStep " << step << "/" << config.num_steps << std::flush;
                      }
                    }
                
                #ifdef LIKWID_PERFMON
                    LIKWID_MARKER_STOP("BH_FORCE_OMP");
                #endif
                
                    timer.stop();
                    stats.num_interactions = solver.get_interaction_count();
                  } else {
                    DirectNBodyOMP solver(Constants::G_NORMALIZED, config.softening);
                    solver.set_num_threads(config.num_threads);
                
                    solver.compute_forces(particles);
                
                    timer.start();
                
                #ifdef LIKWID_PERFMON
                    LIKWID_MARKER_START("DIRECT_FORCE_OMP");
                #endif
                
                    for (int step = 0; step < config.num_steps; ++step) {
                      solver.step(particles, config.timestep);
                
                      if (step % 10 == 0) {
                        std::cout << "\rStep " << step << "/" << config.num_steps << std::flush;
                      }
                    }
                
                #ifdef LIKWID_PERFMON
                    LIKWID_MARKER_STOP("DIRECT_FORCE_OMP");
                #endif
                
                    timer.stop();
                    stats.num_interactions = solver.get_interaction_count();
                  }
                
                #ifdef LIKWID_PERFMON
                  LIKWID_MARKER_CLOSE;
                #endif
                
                  stats.total_time = timer.elapsed_ms();
                  std::cout << "\n";
                  stats.print();
                }
                #endif
                
                #ifdef USE_MPI
                // Run MPI simulation
                void run_mpi(SimConfig &config) {
                  int rank, size;
                  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
                  MPI_Comm_size(MPI_COMM_WORLD, &size);
                
                  if (rank == 0) {
                    std::cout << "\n=== MPI Mode (" << size << " ranks) ===\n";
                  }
                
                  std::vector<Particle> all_particles;
                  if (rank == 0) {
                    all_particles = generate_particles(config);
                  }
                
                  NBodyMPI solver(Constants::G_NORMALIZED, config.theta, config.softening);
                  solver.set_use_barnes_hut(config.use_barnes_hut);
                  solver.initialize(all_particles, config.domain_size);
                
                  MPI_Barrier(MPI_COMM_WORLD);
                  double start_time = MPI_Wtime();
                
                  solver.compute_forces();
                
                  for (int step = 0; step < config.num_steps; ++step) {
                    solver.step(config.timestep);
                
                    if (rank == 0 && step % 10 == 0) {
                      std::cout << "\rStep " << step << "/" << config.num_steps << std::flush;
                    }
                  }
                
                  MPI_Barrier(MPI_COMM_WORLD);
                  double end_time = MPI_Wtime();
                
                  if (rank == 0) {
                    std::cout << "\n\n=== MPI Performance ===\n";
                    std::cout << "Total time: " << (end_time - start_time) * 1000.0 << " ms\n";
                    std::cout << "Communication time: "
                              << solver.get_communication_time() * 1000.0 << " ms\n";
                    std::cout << "Interactions: " << solver.get_interaction_count() << "\n";
                    std::cout << "=======================\n";
                  }
                }
                #endif
                
                #ifdef USE_CUDA
                // Run CUDA simulation
                void run_cuda(SimConfig &config) {
                  std::cout << "\n=== CUDA Mode ===\n";
                
                  if (!NBodyCUDA::is_available()) {
                    std::cerr << "No CUDA device available!\n";
                    return;
                  }
                
                  NBodyCUDA::print_device_info();
                
                  auto particles = generate_particles(config);
                
                  NBodyCUDA solver(Constants::G_NORMALIZED, config.softening);
                  solver.set_block_size(config.block_size);
                  solver.initialize(particles);
                
                  Timer timer;
                  timer.start();
                
                  solver.compute_forces_direct();
                
                  for (int step = 0; step < config.num_steps; ++step) {
                    solver.step(config.timestep);
                
                    if (step % 10 == 0) {
                      std::cout << "\rStep " << step << "/" << config.num_steps << std::flush;
                    }
                  }
                
                  solver.synchronize(particles);
                  timer.stop();
                
                  std::cout << "\n\n=== CUDA Performance ===\n";
                  std::cout << "Total time: " << timer.elapsed_ms() << " ms\n";
                  std::cout << "Kernel time (last): " << solver.get_kernel_time() << " ms\n";
                  std::cout << "Interactions: " << solver.get_interaction_count() << "\n";
                  std::cout << "========================\n";
                }
                #endif
                
       ##### -> int main(int argc, char *argv[]) {
                  SimConfig config;
                  config.parse_args(argc, argv);
                
                #ifdef USE_MPI
                  if (config.mode == SimConfig::Mode::MPI ||
                      config.mode == SimConfig::Mode::HYBRID_MPI_OPENMP ||
                      config.mode == SimConfig::Mode::HYBRID_MPI_CUDA) {
                    MPI_Init(&argc, &argv);
                    MPI_Comm_rank(MPI_COMM_WORLD, &config.my_rank);
                    MPI_Comm_size(MPI_COMM_WORLD, &config.num_ranks);
                  }
                #endif
                
                  if (config.my_rank == 0) {
                    config.print();
                  }
                
                  switch (config.mode) {
                  case SimConfig::Mode::SERIAL:
                    run_serial(config);
                    break;
                
                #ifdef USE_OPENMP
                  case SimConfig::Mode::OPENMP:
                    run_openmp(config);
                    break;
                #endif
                
                #ifdef USE_MPI
                  case SimConfig::Mode::MPI:
                    run_mpi(config);
                    break;
                #endif
                
                #ifdef USE_CUDA
                  case SimConfig::Mode::CUDA:
                    run_cuda(config);
                    break;
                #endif
                
                  default:
                    if (config.my_rank == 0) {
                      std::cerr << "Unsupported mode or feature not compiled.\n";
                    }
                    break;
                  }
                
                #ifdef USE_MPI
                  if (config.mode == SimConfig::Mode::MPI ||
                      config.mode == SimConfig::Mode::HYBRID_MPI_OPENMP ||
                      config.mode == SimConfig::Mode::HYBRID_MPI_CUDA) {
                    MPI_Finalize();
                  }
                #endif
                
                  return 0;
                }


Top 10 Lines:

     Line      Count

       51          1
       58          1

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     0.40   Average executions per line


*** File /home/sunny/Desktop/HPC_Project/src/common/config.cpp:
                #include "config.h"
                #include <chrono>
                #include <cstring>
                #include <iomanip>
                #include <iostream>
                
           1 -> void SimConfig::parse_args(int argc, char **argv) {
                  for (int i = 1; i < argc; ++i) {
                    if (strcmp(argv[i], "--particles") == 0 || strcmp(argv[i], "-n") == 0) {
                      num_particles = std::atoi(argv[++i]);
                    } else if (strcmp(argv[i], "--steps") == 0 || strcmp(argv[i], "-s") == 0) {
                      num_steps = std::atoi(argv[++i]);
                    } else if (strcmp(argv[i], "--dt") == 0) {
                      timestep = std::atof(argv[++i]);
                    } else if (strcmp(argv[i], "--theta") == 0) {
                      theta = std::atof(argv[++i]);
                    } else if (strcmp(argv[i], "--softening") == 0) {
                      softening = std::atof(argv[++i]);
                    } else if (strcmp(argv[i], "--mode") == 0) {
                      const char *mode_str = argv[++i];
                      if (strcmp(mode_str, "serial") == 0)
                        mode = Mode::SERIAL;
                      else if (strcmp(mode_str, "openmp") == 0)
                        mode = Mode::OPENMP;
                      else if (strcmp(mode_str, "mpi") == 0)
                        mode = Mode::MPI;
                      else if (strcmp(mode_str, "cuda") == 0)
                        mode = Mode::CUDA;
                      else if (strcmp(mode_str, "hybrid-mpi-omp") == 0)
                        mode = Mode::HYBRID_MPI_OPENMP;
                      else if (strcmp(mode_str, "hybrid-mpi-cuda") == 0)
                        mode = Mode::HYBRID_MPI_CUDA;
                    } else if (strcmp(argv[i], "--threads") == 0 ||
                               strcmp(argv[i], "-t") == 0) {
                      num_threads = std::atoi(argv[++i]);
                    } else if (strcmp(argv[i], "--block-size") == 0) {
                      block_size = std::atoi(argv[++i]);
                    } else if (strcmp(argv[i], "--direct") == 0) {
                      use_barnes_hut = false;
                    } else if (strcmp(argv[i], "--barnes-hut") == 0) {
                      use_barnes_hut = true;
                    } else if (strcmp(argv[i], "--output") == 0 || strcmp(argv[i], "-o") == 0) {
                      output_positions = true;
                      output_file = argv[++i];
                    } else if (strcmp(argv[i], "--output-interval") == 0) {
                      output_interval = std::atoi(argv[++i]);
                    } else if (strcmp(argv[i], "--no-profile") == 0) {
                      enable_profiling = false;
                    } else if (strcmp(argv[i], "--no-energy") == 0) {
                      enable_energy_check = false;
                    } else if (strcmp(argv[i], "--help") == 0 || strcmp(argv[i], "-h") == 0) {
                      std::cout
                          << "N-Body Simulation\n"
                          << "Usage: nbody [options]\n\n"
                          << "Options:\n"
                          << "  -n, --particles N    Number of particles (default: 10000)\n"
                          << "  -s, --steps N        Number of timesteps (default: 100)\n"
                          << "  --dt T               Timestep size (default: 0.001)\n"
                          << "  --theta T            Barnes-Hut opening angle (default: 0.5)\n"
                          << "  --softening S        Softening parameter (default: 0.01)\n"
                          << "  --mode MODE          Execution mode: serial, openmp, mpi, "
                             "cuda\n"
                          << "  -t, --threads N      Number of OpenMP threads\n"
                          << "  --block-size N       CUDA block size (default: 256)\n"
                          << "  --direct             Use direct O(N) method\n"
                          << "  --barnes-hut         Use Barnes-Hut O(N log N) method\n"
                          << "  -o, --output FILE    Output positions to file\n"
                          << "  --output-interval N  Output every N steps\n"
                          << "  --no-profile         Disable profiling\n"
                          << "  --no-energy          Disable energy conservation check\n"
                          << "  -h, --help           Show this help\n";
                      std::exit(0);
                    }
                  }
                }
                
           1 -> void SimConfig::print() const {
                  std::cout << "\n=== Simulation Configuration ===\n"
                            << "Particles:       " << num_particles << "\n"
                            << "Timesteps:       " << num_steps << "\n"
                            << "dt:              " << timestep << "\n"
                            << "Domain size:     " << domain_size << "\n"
                            << "Algorithm:       "
                            << (use_barnes_hut ? "Barnes-Hut" : "Direct N") << "\n";
                
                  if (use_barnes_hut) {
                    std::cout << "Theta:           " << theta << "\n";
                  }
                
                  std::cout << "Softening:       " << softening << "\n"
                            << "Mode:            ";
                
                  switch (mode) {
                  case Mode::SERIAL:
                    std::cout << "Serial";
                    break;
                  case Mode::OPENMP:
                    std::cout << "OpenMP (" << num_threads << " threads)";
                    break;
                  case Mode::MPI:
                    std::cout << "MPI (" << num_ranks << " ranks)";
                    break;
                  case Mode::CUDA:
                    std::cout << "CUDA (block size: " << block_size << ")";
                    break;
                  case Mode::HYBRID_MPI_OPENMP:
                    std::cout << "Hybrid MPI+OpenMP";
                    break;
                  case Mode::HYBRID_MPI_CUDA:
                    std::cout << "Hybrid MPI+CUDA";
                    break;
                  }
                  std::cout << "\n================================\n\n";
                }
                
                // Timer implementation
                static double get_time() {
                  auto now = std::chrono::high_resolution_clock::now();
                  auto duration = now.time_since_epoch();
                  return std::chrono::duration<double>(duration).count();
                }
                
           1 -> void Timer::start() {
                  start_time_ = get_time();
                  running_ = true;
                }
                
           1 -> void Timer::stop() {
                  end_time_ = get_time();
                  running_ = false;
                }
                
           1 -> double Timer::elapsed_ms() const {
                  if (running_) {
                    return (get_time() - start_time_) * 1000.0;
                  }
                  return (end_time_ - start_time_) * 1000.0;
                }
                
       ##### -> double Timer::elapsed_s() const { return elapsed_ms() / 1000.0; }
                
       ##### -> void Timer::reset() {
                  start_time_ = 0;
                  end_time_ = 0;
                  running_ = false;
                }
                
                // PerfStats implementation
           1 -> void PerfStats::print() const {
                  std::cout << std::fixed << std::setprecision(3);
                  std::cout << "\n=== Performance Statistics ===\n"
                            << "Tree build time:    " << tree_build_time << " ms\n"
                            << "Force compute time: " << force_compute_time << " ms\n"
                            << "Integration time:   " << integration_time << " ms\n";
                  if (communication_time > 0) {
                    std::cout << "Communication time: " << communication_time << " ms\n";
                  }
                  std::cout << "Total time:         " << total_time << " ms\n"
                            << "Interactions:       " << num_interactions << "\n";
                  if (gflops > 0) {
                    std::cout << "Performance:        " << gflops << " GFLOPS\n";
                  }
                  std::cout << "==============================\n\n";
                }
                
       ##### -> void PerfStats::accumulate(const PerfStats &other) {
                  tree_build_time += other.tree_build_time;
                  force_compute_time += other.force_compute_time;
                  integration_time += other.integration_time;
                  communication_time += other.communication_time;
                  total_time += other.total_time;
                  num_interactions += other.num_interactions;
                }


Top 10 Lines:

     Line      Count

        7          1
       77          1
      123          1
      128          1
      133          1
      149          1

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

        6   Total number of line executions
     0.67   Average executions per line


*** File /home/sunny/Desktop/HPC_Project/src/serial/generators.cpp:
                #include "generators.h"
                #include <cmath>
                #include <random>
                
                std::vector<Particle> generate_uniform(int n, double domain_size,
       ##### ->                                        double total_mass, unsigned int seed) {
                  std::vector<Particle> particles(n);
                  std::mt19937 rng(seed);
                  std::uniform_real_distribution<double> pos_dist(0.0, domain_size);
                  std::uniform_real_distribution<double> vel_dist(-0.1, 0.1);
                
                  double mass_per_particle = total_mass / n;
                
                  for (int i = 0; i < n; ++i) {
                    Vector3D pos(pos_dist(rng), pos_dist(rng), pos_dist(rng));
                    Vector3D vel(vel_dist(rng), vel_dist(rng), vel_dist(rng));
                    particles[i] = Particle(pos, vel, mass_per_particle, i);
                  }
                
                  return particles;
                }
                
                std::vector<Particle> generate_gaussian_clusters(int n, int num_clusters,
                                                                 double domain_size,
                                                                 double cluster_std,
                                                                 double total_mass,
       ##### ->                                                  unsigned int seed) {
                  std::vector<Particle> particles(n);
                  std::mt19937 rng(seed);
                  std::uniform_real_distribution<double> center_dist(
                      cluster_std * 2, domain_size - cluster_std * 2);
                  std::normal_distribution<double> offset_dist(0.0, cluster_std);
                  std::uniform_real_distribution<double> vel_dist(-0.05, 0.05);
                
                  double mass_per_particle = total_mass / n;
                  int particles_per_cluster = n / num_clusters;
                
                  std::vector<Vector3D> centers(num_clusters);
                  for (int c = 0; c < num_clusters; ++c) {
                    centers[c] = Vector3D(center_dist(rng), center_dist(rng), center_dist(rng));
                  }
                
                  for (int i = 0; i < n; ++i) {
                    int cluster = i / particles_per_cluster;
                    if (cluster >= num_clusters)
                      cluster = num_clusters - 1;
                
                    Vector3D offset(offset_dist(rng), offset_dist(rng), offset_dist(rng));
                    Vector3D pos = centers[cluster] + offset;
                    Vector3D vel(vel_dist(rng), vel_dist(rng), vel_dist(rng));
                
                    particles[i] = Particle(pos, vel, mass_per_particle, i);
                  }
                
                  return particles;
                }
                
                std::vector<Particle> generate_galaxy(int n, double radius, double total_mass,
       ##### ->                                       double arm_count, unsigned int seed) {
                  std::vector<Particle> particles(n);
                  std::mt19937 rng(seed);
                  std::uniform_real_distribution<double> r_dist(0.1, 1.0);
                  std::uniform_real_distribution<double> theta_dist(0.0, 2.0 * M_PI);
                  std::normal_distribution<double> z_dist(0.0, radius * 0.05);
                  std::normal_distribution<double> vel_noise(0.0, 0.01);
                
                  double mass_per_particle = total_mass / n;
                
                  // Central bulge particles (10%)
                  int bulge_count = n / 10;
                  std::normal_distribution<double> bulge_dist(0.0, radius * 0.1);
                
                  for (int i = 0; i < bulge_count; ++i) {
                    Vector3D pos(bulge_dist(rng), bulge_dist(rng), bulge_dist(rng) * 0.5);
                    Vector3D vel(vel_noise(rng), vel_noise(rng), vel_noise(rng));
                    particles[i] = Particle(pos, vel, mass_per_particle * 2, i);
                  }
                
                  // Spiral arm particles
                  for (int i = bulge_count; i < n; ++i) {
                    double r = pow(r_dist(rng), 0.5) * radius;
                    double base_theta = theta_dist(rng);
                    double spiral_theta =
                        base_theta + (r / radius) * 2.0 * M_PI * arm_count * 0.5;
                
                    std::normal_distribution<double> theta_noise(0.0, 0.2);
                    spiral_theta += theta_noise(rng);
                
                    double x = r * cos(spiral_theta);
                    double y = r * sin(spiral_theta);
                    double z = z_dist(rng);
                
                    Vector3D pos(x, y, z);
                
                    double v_circ = sqrt(total_mass * 0.5 / (r + 0.1));
                    double vx = -v_circ * sin(spiral_theta) + vel_noise(rng);
                    double vy = v_circ * cos(spiral_theta) + vel_noise(rng);
                    double vz = vel_noise(rng);
                
                    Vector3D vel(vx, vy, vz);
                    particles[i] = Particle(pos, vel, mass_per_particle, i);
                  }
                
                  return particles;
                }
                
                std::vector<Particle> generate_collision(int n, double separation,
                                                         double radius, double total_mass,
       ##### ->                                          unsigned int seed) {
                  int n_each = n / 2;
                
                  auto galaxy1 = generate_galaxy(n_each, radius, total_mass / 2, 2, seed);
                  auto galaxy2 =
                      generate_galaxy(n - n_each, radius, total_mass / 2, 2, seed + 1);
                
                  Vector3D offset(separation, 0, 0);
                  Vector3D vel_offset(-0.5, 0.2, 0);
                
                  for (auto &p : galaxy2) {
                    p.position = p.position + offset;
                    p.velocity = p.velocity + vel_offset;
                    p.id += n_each;
                  }
                
                  std::vector<Particle> particles;
                  particles.reserve(n);
                  particles.insert(particles.end(), galaxy1.begin(), galaxy1.end());
                  particles.insert(particles.end(), galaxy2.begin(), galaxy2.end());
                
                  return particles;
                }
                
                std::vector<Particle> generate_plummer(int n, double scale_radius,
           1 ->                                        double total_mass, unsigned int seed) {
                  std::vector<Particle> particles(n);
                  std::mt19937 rng(seed);
                  std::uniform_real_distribution<double> u_dist(0.0, 1.0);
                
                  double mass_per_particle = total_mass / n;
                
                  for (int i = 0; i < n; ++i) {
                    double u = u_dist(rng);
                    double r = scale_radius / sqrt(pow(u, -2.0 / 3.0) - 1.0);
                    r = std::min(r, scale_radius * 100.0);
                
                    double cos_theta = 2.0 * u_dist(rng) - 1.0;
                    double sin_theta = sqrt(1.0 - cos_theta * cos_theta);
                    double phi = 2.0 * M_PI * u_dist(rng);
                
                    double x = r * sin_theta * cos(phi);
                    double y = r * sin_theta * sin(phi);
                    double z = r * cos_theta;
                
                    Vector3D pos(x, y, z);
                
                    double v_escape =
                        sqrt(2.0 * total_mass / sqrt(r * r + scale_radius * scale_radius));
                
                    double q, g;
                    do {
                      q = u_dist(rng);
                      g = q * q * pow(1.0 - q * q, 3.5);
                    } while (u_dist(rng) > g / 0.1);
                
                    double v = q * v_escape * 0.5;
                
                    double cos_theta_v = 2.0 * u_dist(rng) - 1.0;
                    double sin_theta_v = sqrt(1.0 - cos_theta_v * cos_theta_v);
                    double phi_v = 2.0 * M_PI * u_dist(rng);
                
                    double vx = v * sin_theta_v * cos(phi_v);
                    double vy = v * sin_theta_v * sin(phi_v);
                    double vz = v * cos_theta_v;
                
                    Vector3D vel(vx, vy, vz);
                    particles[i] = Particle(pos, vel, mass_per_particle, i);
                  }
                
                  return particles;
                }


Top 10 Lines:

     Line      Count

      134          1

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.20   Average executions per line


*** File /usr/include/c++/13/bits/random.tcc:
                // random number generation (out of line) -*- C++ -*-
                
                // Copyright (C) 2009-2023 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/random.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{random}
                 */
                
                #ifndef _RANDOM_TCC
                #define _RANDOM_TCC 1
                
                #include <numeric> // std::accumulate and std::partial_sum
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /// @cond undocumented
                  // (Further) implementation-space details.
                  namespace __detail
                  {
                    // General case for x = (ax + c) mod m -- use Schrage's algorithm
                    // to avoid integer overflow.
                    //
                    // Preconditions:  a > 0, m > 0.
                    //
                    // Note: only works correctly for __m % __a < __m / __a.
                    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c>
                      _Tp
                      _Mod<_Tp, __m, __a, __c, false, true>::
                      __calc(_Tp __x)
                      {
                	if (__a == 1)
                	  __x %= __m;
                	else
                	  {
                	    static const _Tp __q = __m / __a;
                	    static const _Tp __r = __m % __a;
                
                	    _Tp __t1 = __a * (__x % __q);
                	    _Tp __t2 = __r * (__x / __q);
                	    if (__t1 >= __t2)
                	      __x = __t1 - __t2;
                	    else
                	      __x = __m - __t2 + __t1;
                	  }
                
                	if (__c != 0)
                	  {
                	    const _Tp __d = __m - __x;
                	    if (__d > __c)
                	      __x += __c;
                	    else
                	      __x = __c - __d;
                	  }
                	return __x;
                      }
                
                    template<typename _InputIterator, typename _OutputIterator,
                	     typename _Tp>
                      _OutputIterator
                      __normalize(_InputIterator __first, _InputIterator __last,
                		  _OutputIterator __result, const _Tp& __factor)
                      {
                	for (; __first != __last; ++__first, ++__result)
                	  *__result = *__first / __factor;
                	return __result;
                      }
                
                  } // namespace __detail
                  /// @endcond
                
                #if ! __cpp_inline_variables
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    constexpr _UIntType
                    linear_congruential_engine<_UIntType, __a, __c, __m>::multiplier;
                
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    constexpr _UIntType
                    linear_congruential_engine<_UIntType, __a, __c, __m>::increment;
                
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    constexpr _UIntType
                    linear_congruential_engine<_UIntType, __a, __c, __m>::modulus;
                
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    constexpr _UIntType
                    linear_congruential_engine<_UIntType, __a, __c, __m>::default_seed;
                #endif
                
                  /**
                   * Seeds the LCR with integral value @p __s, adjusted so that the
                   * ring identity is never a member of the convergence set.
                   */
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    void
                    linear_congruential_engine<_UIntType, __a, __c, __m>::
                    seed(result_type __s)
                    {
                      if ((__detail::__mod<_UIntType, __m>(__c) == 0)
                	  && (__detail::__mod<_UIntType, __m>(__s) == 0))
                	_M_x = 1;
                      else
                	_M_x = __detail::__mod<_UIntType, __m>(__s);
                    }
                
                  /**
                   * Seeds the LCR engine with a value generated by @p __q.
                   */
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    template<typename _Sseq>
                      auto
                      linear_congruential_engine<_UIntType, __a, __c, __m>::
                      seed(_Sseq& __q)
                      -> _If_seed_seq<_Sseq>
                      {
                	const _UIntType __k0 = __m == 0 ? std::numeric_limits<_UIntType>::digits
                	                                : std::__lg(__m);
                	const _UIntType __k = (__k0 + 31) / 32;
                	uint_least32_t __arr[__k + 3];
                	__q.generate(__arr + 0, __arr + __k + 3);
                	_UIntType __factor = 1u;
                	_UIntType __sum = 0u;
                	for (size_t __j = 0; __j < __k; ++__j)
                	  {
                	    __sum += __arr[__j + 3] * __factor;
                	    __factor *= __detail::_Shift<_UIntType, 32>::__value;
                	  }
                	seed(__sum);
                      }
                
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const linear_congruential_engine<_UIntType,
                						__a, __c, __m>& __lcr)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
                      __os.fill(__os.widen(' '));
                
                      __os << __lcr._M_x;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      return __os;
                    }
                
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       linear_congruential_engine<_UIntType, __a, __c, __m>& __lcr)
                    {
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec);
                
                      __is >> __lcr._M_x;
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                #if ! __cpp_inline_variables
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::word_size;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::state_size;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::shift_size;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::mask_bits;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr _UIntType
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::xor_mask;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_u;
                   
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr _UIntType
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_d;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_s;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr _UIntType
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_b;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_t;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr _UIntType
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_c;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_l;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr _UIntType
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::
                                                              initialization_multiplier;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr _UIntType
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::default_seed;
                #endif
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    void
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::
                    seed(result_type __sd)
                    {
                      _M_x[0] = __detail::__mod<_UIntType,
                	__detail::_Shift<_UIntType, __w>::__value>(__sd);
                
                      for (size_t __i = 1; __i < state_size; ++__i)
                	{
                	  _UIntType __x = _M_x[__i - 1];
                	  __x ^= __x >> (__w - 2);
                	  __x *= __f;
                	  __x += __detail::__mod<_UIntType, __n>(__i);
                	  _M_x[__i] = __detail::__mod<_UIntType,
                	    __detail::_Shift<_UIntType, __w>::__value>(__x);
                	}
                      _M_p = state_size;
                    }
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    template<typename _Sseq>
                      auto
                      mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			      __s, __b, __t, __c, __l, __f>::
                      seed(_Sseq& __q)
                      -> _If_seed_seq<_Sseq>
                      {
                	const _UIntType __upper_mask = (~_UIntType()) << __r;
                	const size_t __k = (__w + 31) / 32;
                	uint_least32_t __arr[__n * __k];
                	__q.generate(__arr + 0, __arr + __n * __k);
                
                	bool __zero = true;
                	for (size_t __i = 0; __i < state_size; ++__i)
                	  {
                	    _UIntType __factor = 1u;
                	    _UIntType __sum = 0u;
                	    for (size_t __j = 0; __j < __k; ++__j)
                	      {
                		__sum += __arr[__k * __i + __j] * __factor;
                		__factor *= __detail::_Shift<_UIntType, 32>::__value;
                	      }
                	    _M_x[__i] = __detail::__mod<_UIntType,
                	      __detail::_Shift<_UIntType, __w>::__value>(__sum);
                
                	    if (__zero)
                	      {
                		if (__i == 0)
                		  {
                		    if ((_M_x[0] & __upper_mask) != 0u)
                		      __zero = false;
                		  }
                		else if (_M_x[__i] != 0u)
                		  __zero = false;
                	      }
                	  }
                        if (__zero)
                          _M_x[0] = __detail::_Shift<_UIntType, __w - 1>::__value;
                	_M_p = state_size;
                      }
                
                  template<typename _UIntType, size_t __w,
                	   size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    void
         311 ->     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::
                    _M_gen_rand(void)
                    {
                      const _UIntType __upper_mask = (~_UIntType()) << __r;
                      const _UIntType __lower_mask = ~__upper_mask;
                
                      for (size_t __k = 0; __k < (__n - __m); ++__k)
                        {
                	  _UIntType __y = ((_M_x[__k] & __upper_mask)
                			   | (_M_x[__k + 1] & __lower_mask));
                	  _M_x[__k] = (_M_x[__k + __m] ^ (__y >> 1)
                		       ^ ((__y & 0x01) ? __a : 0));
                        }
                
                      for (size_t __k = (__n - __m); __k < (__n - 1); ++__k)
                	{
                	  _UIntType __y = ((_M_x[__k] & __upper_mask)
                			   | (_M_x[__k + 1] & __lower_mask));
                	  _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)
                		       ^ ((__y & 0x01) ? __a : 0));
                	}
                
                      _UIntType __y = ((_M_x[__n - 1] & __upper_mask)
                		       | (_M_x[0] & __lower_mask));
                      _M_x[__n - 1] = (_M_x[__m - 1] ^ (__y >> 1)
                		       ^ ((__y & 0x01) ? __a : 0));
                      _M_p = 0;
                    }
                
                  template<typename _UIntType, size_t __w,
                	   size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    void
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::
                    discard(unsigned long long __z)
                    {
                      while (__z > state_size - _M_p)
                	{
                	  __z -= state_size - _M_p;
                	  _M_gen_rand();
                	}
                      _M_p += __z;
                    }
                
                  template<typename _UIntType, size_t __w,
                	   size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    typename
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::result_type
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::
                    operator()()
                    {
                      // Reload the vector - cost is O(n) amortized over n calls.
                      if (_M_p >= state_size)
                	_M_gen_rand();
                
                      // Calculate o(x(i)).
                      result_type __z = _M_x[_M_p++];
                      __z ^= (__z >> __u) & __d;
                      __z ^= (__z << __s) & __b;
                      __z ^= (__z << __t) & __c;
                      __z ^= (__z >> __l);
                
                      return __z;
                    }
                
                  template<typename _UIntType, size_t __w,
                	   size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const mersenne_twister_engine<_UIntType, __w, __n, __m,
                	       __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
                      __os.fill(__space);
                
                      for (size_t __i = 0; __i < __n; ++__i)
                	__os << __x._M_x[__i] << __space;
                      __os << __x._M_p;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      return __os;
                    }
                
                  template<typename _UIntType, size_t __w,
                	   size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       mersenne_twister_engine<_UIntType, __w, __n, __m,
                	       __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __x)
                    {
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      for (size_t __i = 0; __i < __n; ++__i)
                	__is >> __x._M_x[__i];
                      __is >> __x._M_p;
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                #if ! __cpp_inline_variables
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    constexpr size_t
                    subtract_with_carry_engine<_UIntType, __w, __s, __r>::word_size;
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    constexpr size_t
                    subtract_with_carry_engine<_UIntType, __w, __s, __r>::short_lag;
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    constexpr size_t
                    subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag;
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    constexpr uint_least32_t
                    subtract_with_carry_engine<_UIntType, __w, __s, __r>::default_seed;
                #endif
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    void
                    subtract_with_carry_engine<_UIntType, __w, __s, __r>::
                    seed(result_type __value)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3809. Is std::subtract_with_carry_engine<uint16_t> supposed to work?
                      // 4014. LWG 3809 changes behavior of some existing code
                      std::linear_congruential_engine<uint_least32_t, 40014u, 0u, 2147483563u>
                	__lcg(__value == 0u ? default_seed : __value % 2147483563u);
                
                      const size_t __n = (__w + 31) / 32;
                
                      for (size_t __i = 0; __i < long_lag; ++__i)
                	{
                	  _UIntType __sum = 0u;
                	  _UIntType __factor = 1u;
                	  for (size_t __j = 0; __j < __n; ++__j)
                	    {
                	      __sum += __detail::__mod<uint_least32_t,
                		       __detail::_Shift<uint_least32_t, 32>::__value>
                			 (__lcg()) * __factor;
                	      __factor *= __detail::_Shift<_UIntType, 32>::__value;
                	    }
                	  _M_x[__i] = __detail::__mod<_UIntType,
                	    __detail::_Shift<_UIntType, __w>::__value>(__sum);
                	}
                      _M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;
                      _M_p = 0;
                    }
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    template<typename _Sseq>
                      auto
                      subtract_with_carry_engine<_UIntType, __w, __s, __r>::
                      seed(_Sseq& __q)
                      -> _If_seed_seq<_Sseq>
                      {
                	const size_t __k = (__w + 31) / 32;
                	uint_least32_t __arr[__r * __k];
                	__q.generate(__arr + 0, __arr + __r * __k);
                
                	for (size_t __i = 0; __i < long_lag; ++__i)
                	  {
                	    _UIntType __sum = 0u;
                	    _UIntType __factor = 1u;
                	    for (size_t __j = 0; __j < __k; ++__j)
                	      {
                		__sum += __arr[__k * __i + __j] * __factor;
                		__factor *= __detail::_Shift<_UIntType, 32>::__value;
                	      }
                	    _M_x[__i] = __detail::__mod<_UIntType,
                	      __detail::_Shift<_UIntType, __w>::__value>(__sum);
                	  }
                	_M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;
                	_M_p = 0;
                      }
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    typename subtract_with_carry_engine<_UIntType, __w, __s, __r>::
                	     result_type
                    subtract_with_carry_engine<_UIntType, __w, __s, __r>::
                    operator()()
                    {
                      // Derive short lag index from current index.
                      long __ps = _M_p - short_lag;
                      if (__ps < 0)
                	__ps += long_lag;
                
                      // Calculate new x(i) without overflow or division.
                      // NB: Thanks to the requirements for _UIntType, _M_x[_M_p] + _M_carry
                      // cannot overflow.
                      _UIntType __xi;
                      if (_M_x[__ps] >= _M_x[_M_p] + _M_carry)
                	{
                	  __xi = _M_x[__ps] - _M_x[_M_p] - _M_carry;
                	  _M_carry = 0;
                	}
                      else
                	{
                	  __xi = (__detail::_Shift<_UIntType, __w>::__value
                		  - _M_x[_M_p] - _M_carry + _M_x[__ps]);
                	  _M_carry = 1;
                	}
                      _M_x[_M_p] = __xi;
                
                      // Adjust current index to loop around in ring buffer.
                      if (++_M_p >= long_lag)
                	_M_p = 0;
                
                      return __xi;
                    }
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const subtract_with_carry_engine<_UIntType,
                						__w, __s, __r>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
                      __os.fill(__space);
                
                      for (size_t __i = 0; __i < __r; ++__i)
                	__os << __x._M_x[__i] << __space;
                      __os << __x._M_carry << __space << __x._M_p;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      return __os;
                    }
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       subtract_with_carry_engine<_UIntType, __w, __s, __r>& __x)
                    {
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      for (size_t __i = 0; __i < __r; ++__i)
                	__is >> __x._M_x[__i];
                      __is >> __x._M_carry;
                      __is >> __x._M_p;
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                #if ! __cpp_inline_variables
                  template<typename _RandomNumberEngine, size_t __p, size_t __r>
                    constexpr size_t
                    discard_block_engine<_RandomNumberEngine, __p, __r>::block_size;
                
                  template<typename _RandomNumberEngine, size_t __p, size_t __r>
                    constexpr size_t
                    discard_block_engine<_RandomNumberEngine, __p, __r>::used_block;
                #endif
                
                  template<typename _RandomNumberEngine, size_t __p, size_t __r>
                    typename discard_block_engine<_RandomNumberEngine,
                			   __p, __r>::result_type
                    discard_block_engine<_RandomNumberEngine, __p, __r>::
                    operator()()
                    {
                      if (_M_n >= used_block)
                	{
                	  _M_b.discard(block_size - _M_n);
                	  _M_n = 0;
                	}
                      ++_M_n;
                      return _M_b();
                    }
                
                  template<typename _RandomNumberEngine, size_t __p, size_t __r,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const discard_block_engine<_RandomNumberEngine,
                	       __p, __r>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
                      __os.fill(__space);
                
                      __os << __x.base() << __space << __x._M_n;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      return __os;
                    }
                
                  template<typename _RandomNumberEngine, size_t __p, size_t __r,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       discard_block_engine<_RandomNumberEngine, __p, __r>& __x)
                    {
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      __is >> __x._M_b >> __x._M_n;
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
                    typename independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::
                      result_type
                    independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::
                    operator()()
                    {
                      typedef typename _RandomNumberEngine::result_type _Eresult_type;
                      const _Eresult_type __r
                	= (_M_b.max() - _M_b.min() < std::numeric_limits<_Eresult_type>::max()
                	   ? _M_b.max() - _M_b.min() + 1 : 0);
                      const unsigned __edig = std::numeric_limits<_Eresult_type>::digits;
                      const unsigned __m = __r ? std::__lg(__r) : __edig;
                
                      typedef typename std::common_type<_Eresult_type, result_type>::type
                	__ctype;
                      const unsigned __cdig = std::numeric_limits<__ctype>::digits;
                
                      unsigned __n, __n0;
                      __ctype __s0, __s1, __y0, __y1;
                
                      for (size_t __i = 0; __i < 2; ++__i)
                	{
                	  __n = (__w + __m - 1) / __m + __i;
                	  __n0 = __n - __w % __n;
                	  const unsigned __w0 = __w / __n;  // __w0 <= __m
                
                	  __s0 = 0;
                	  __s1 = 0;
                	  if (__w0 < __cdig)
                	    {
                	      __s0 = __ctype(1) << __w0;
                	      __s1 = __s0 << 1;
                	    }
                
                	  __y0 = 0;
                	  __y1 = 0;
                	  if (__r)
                	    {
                	      __y0 = __s0 * (__r / __s0);
                	      if (__s1)
                		__y1 = __s1 * (__r / __s1);
                
                	      if (__r - __y0 <= __y0 / __n)
                		break;
                	    }
                	  else
                	    break;
                	}
                
                      result_type __sum = 0;
                      for (size_t __k = 0; __k < __n0; ++__k)
                	{
                	  __ctype __u;
                	  do
                	    __u = _M_b() - _M_b.min();
                	  while (__y0 && __u >= __y0);
                	  __sum = __s0 * __sum + (__s0 ? __u % __s0 : __u);
                	}
                      for (size_t __k = __n0; __k < __n; ++__k)
                	{
                	  __ctype __u;
                	  do
                	    __u = _M_b() - _M_b.min();
                	  while (__y1 && __u >= __y1);
                	  __sum = __s1 * __sum + (__s1 ? __u % __s1 : __u);
                	}
                      return __sum;
                    }
                
                #if ! __cpp_inline_variables
                  template<typename _RandomNumberEngine, size_t __k>
                    constexpr size_t
                    shuffle_order_engine<_RandomNumberEngine, __k>::table_size;
                #endif
                
                  namespace __detail
                  {
                    // Determine whether an integer is representable as double.
                    template<typename _Tp>
                      constexpr bool
                      __representable_as_double(_Tp __x) noexcept
                      {
                	static_assert(numeric_limits<_Tp>::is_integer, "");
                	static_assert(!numeric_limits<_Tp>::is_signed, "");
                	// All integers <= 2^53 are representable.
                	return (__x <= (1ull << __DBL_MANT_DIG__))
                	  // Between 2^53 and 2^54 only even numbers are representable.
                	  || (!(__x & 1) && __detail::__representable_as_double(__x >> 1));
                      }
                
                    // Determine whether x+1 is representable as double.
                    template<typename _Tp>
                      constexpr bool
                      __p1_representable_as_double(_Tp __x) noexcept
                      {
                	static_assert(numeric_limits<_Tp>::is_integer, "");
                	static_assert(!numeric_limits<_Tp>::is_signed, "");
                	return numeric_limits<_Tp>::digits < __DBL_MANT_DIG__
                	  || (bool(__x + 1u) // return false if x+1 wraps around to zero
                	      && __detail::__representable_as_double(__x + 1u));
                      }
                  }
                
                  template<typename _RandomNumberEngine, size_t __k>
                    typename shuffle_order_engine<_RandomNumberEngine, __k>::result_type
                    shuffle_order_engine<_RandomNumberEngine, __k>::
                    operator()()
                    {
                      constexpr result_type __range = max() - min();
                      size_t __j = __k;
                      const result_type __y = _M_y - min();
                      // Avoid using slower long double arithmetic if possible.
                      if _GLIBCXX17_CONSTEXPR (__detail::__p1_representable_as_double(__range))
                	__j *= __y / (__range + 1.0);
                      else
                	__j *= __y / (__range + 1.0L);
                      _M_y = _M_v[__j];
                      _M_v[__j] = _M_b();
                
                      return _M_y;
                    }
                
                  template<typename _RandomNumberEngine, size_t __k,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const shuffle_order_engine<_RandomNumberEngine, __k>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
                      __os.fill(__space);
                
                      __os << __x.base();
                      for (size_t __i = 0; __i < __k; ++__i)
                	__os << __space << __x._M_v[__i];
                      __os << __space << __x._M_y;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      return __os;
                    }
                
                  template<typename _RandomNumberEngine, size_t __k,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       shuffle_order_engine<_RandomNumberEngine, __k>& __x)
                    {
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      __is >> __x._M_b;
                      for (size_t __i = 0; __i < __k; ++__i)
                	__is >> __x._M_v[__i];
                      __is >> __x._M_y;
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const uniform_int_distribution<_IntType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                
                      __os << __x.a() << __space << __x.b();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      return __os;
                    }
                
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       uniform_int_distribution<_IntType>& __x)
                    {
                      using param_type
                	= typename uniform_int_distribution<_IntType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _IntType __a, __b;
                      if (__is >> __a >> __b)
                	__x.param(param_type(__a, __b));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      uniform_real_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	auto __range = __p.b() - __p.a();
                	while (__f != __t)
                	  *__f++ = __aurng() * __range + __p.a();
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const uniform_real_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.a() << __space << __x.b();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       uniform_real_distribution<_RealType>& __x)
                    {
                      using param_type
                	= typename uniform_real_distribution<_RealType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::skipws);
                
                      _RealType __a, __b;
                      if (__is >> __a >> __b)
                	__x.param(param_type(__a, __b));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _ForwardIterator,
                	   typename _UniformRandomNumberGenerator>
                    void
                    std::bernoulli_distribution::
                    __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		    _UniformRandomNumberGenerator& __urng,
                		    const param_type& __p)
                    {
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	__aurng(__urng);
                      auto __limit = __p.p() * (__aurng.max() - __aurng.min());
                
                      while (__f != __t)
                	*__f++ = (__aurng() - __aurng.min()) < __limit;
                    }
                
                  template<typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const bernoulli_distribution& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__os.widen(' '));
                      __os.precision(std::numeric_limits<double>::max_digits10);
                
                      __os << __x.p();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename geometric_distribution<_IntType>::result_type
                      geometric_distribution<_IntType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	// About the epsilon thing see this thread:
                	// http://gcc.gnu.org/ml/gcc-patches/2006-10/msg00971.html
                	const double __naf =
                	  (1 - std::numeric_limits<double>::epsilon()) / 2;
                	// The largest _RealType convertible to _IntType.
                	const double __thr =
                	  std::numeric_limits<_IntType>::max() + __naf;
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	double __cand;
                	do
                	  __cand = std::floor(std::log(1.0 - __aurng()) / __param._M_log_1_p);
                	while (__cand >= __thr);
                
                	return result_type(__cand + __naf);
                      }
                
                  template<typename _IntType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      geometric_distribution<_IntType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	// About the epsilon thing see this thread:
                	// http://gcc.gnu.org/ml/gcc-patches/2006-10/msg00971.html
                	const double __naf =
                	  (1 - std::numeric_limits<double>::epsilon()) / 2;
                	// The largest _RealType convertible to _IntType.
                	const double __thr =
                	  std::numeric_limits<_IntType>::max() + __naf;
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	while (__f != __t)
                	  {
                	    double __cand;
                	    do
                	      __cand = std::floor(std::log(1.0 - __aurng())
                				  / __param._M_log_1_p);
                	    while (__cand >= __thr);
                
                	    *__f++ = __cand + __naf;
                	  }
                      }
                
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const geometric_distribution<_IntType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__os.widen(' '));
                      __os.precision(std::numeric_limits<double>::max_digits10);
                
                      __os << __x.p();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       geometric_distribution<_IntType>& __x)
                    {
                      using param_type = typename geometric_distribution<_IntType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::skipws);
                
                      double __p;
                      if (__is >> __p)
                	__x.param(param_type(__p));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                  // This is Leger's algorithm, also in Devroye, Ch. X, Example 1.5.
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename negative_binomial_distribution<_IntType>::result_type
                      negative_binomial_distribution<_IntType>::
                      operator()(_UniformRandomNumberGenerator& __urng)
                      {
                	const double __y = _M_gd(__urng);
                
                	// XXX Is the constructor too slow?
                	std::poisson_distribution<result_type> __poisson(__y);
                	return __poisson(__urng);
                      }
                
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename negative_binomial_distribution<_IntType>::result_type
                      negative_binomial_distribution<_IntType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __p)
                      {
                	typedef typename std::gamma_distribution<double>::param_type
                	  param_type;
                	
                	const double __y =
                	  _M_gd(__urng, param_type(__p.k(), (1.0 - __p.p()) / __p.p()));
                
                	std::poisson_distribution<result_type> __poisson(__y);
                	return __poisson(__urng);
                      }
                
                  template<typename _IntType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      negative_binomial_distribution<_IntType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	while (__f != __t)
                	  {
                	    const double __y = _M_gd(__urng);
                
                	    // XXX Is the constructor too slow?
                	    std::poisson_distribution<result_type> __poisson(__y);
                	    *__f++ = __poisson(__urng);
                	  }
                      }
                
                  template<typename _IntType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      negative_binomial_distribution<_IntType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	typename std::gamma_distribution<result_type>::param_type
                	  __p2(__p.k(), (1.0 - __p.p()) / __p.p());
                
                	while (__f != __t)
                	  {
                	    const double __y = _M_gd(__urng, __p2);
                
                	    std::poisson_distribution<result_type> __poisson(__y);
                	    *__f++ = __poisson(__urng);
                	  }
                      }
                
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const negative_binomial_distribution<_IntType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__os.widen(' '));
                      __os.precision(std::numeric_limits<double>::max_digits10);
                
                      __os << __x.k() << __space << __x.p()
                	   << __space << __x._M_gd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       negative_binomial_distribution<_IntType>& __x)
                    {
                      using param_type
                	= typename negative_binomial_distribution<_IntType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::skipws);
                
                      _IntType __k;
                      double __p;
                      if (__is >> __k >> __p >> __x._M_gd)
                	__x.param(param_type(__k, __p));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _IntType>
                    void
                    poisson_distribution<_IntType>::param_type::
                    _M_initialize()
                    {
                #if _GLIBCXX_USE_C99_MATH_TR1
                      if (_M_mean >= 12)
                	{
                	  const double __m = std::floor(_M_mean);
                	  _M_lm_thr = std::log(_M_mean);
                	  _M_lfm = std::lgamma(__m + 1);
                	  _M_sm = std::sqrt(__m);
                
                	  const double __pi_4 = 0.7853981633974483096156608458198757L;
                	  const double __dx = std::sqrt(2 * __m * std::log(32 * __m
                							      / __pi_4));
                	  _M_d = std::round(std::max<double>(6.0, std::min(__m, __dx)));
                	  const double __cx = 2 * __m + _M_d;
                	  _M_scx = std::sqrt(__cx / 2);
                	  _M_1cx = 1 / __cx;
                
                	  _M_c2b = std::sqrt(__pi_4 * __cx) * std::exp(_M_1cx);
                	  _M_cb = 2 * __cx * std::exp(-_M_d * _M_1cx * (1 + _M_d / 2))
                		/ _M_d;
                	}
                      else
                #endif
                	_M_lm_thr = std::exp(-_M_mean);
                      }
                
                  /**
                   * A rejection algorithm when mean >= 12 and a simple method based
                   * upon the multiplication of uniform random variates otherwise.
                   * NB: The former is available only if _GLIBCXX_USE_C99_MATH_TR1
                   * is defined.
                   *
                   * Reference:
                   * Devroye, L. Non-Uniform Random Variates Generation. Springer-Verlag,
                   * New York, 1986, Ch. X, Sects. 3.3 & 3.4 (+ Errata!).
                   */
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename poisson_distribution<_IntType>::result_type
                      poisson_distribution<_IntType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                #if _GLIBCXX_USE_C99_MATH_TR1
                	if (__param.mean() >= 12)
                	  {
                	    double __x;
                
                	    // See comments above...
                	    const double __naf =
                	      (1 - std::numeric_limits<double>::epsilon()) / 2;
                	    const double __thr =
                	      std::numeric_limits<_IntType>::max() + __naf;
                
                	    const double __m = std::floor(__param.mean());
                	    // sqrt(pi / 2)
                	    const double __spi_2 = 1.2533141373155002512078826424055226L;
                	    const double __c1 = __param._M_sm * __spi_2;
                	    const double __c2 = __param._M_c2b + __c1;
                	    const double __c3 = __c2 + 1;
                	    const double __c4 = __c3 + 1;
                	    // 1 / 78
                	    const double __178 = 0.0128205128205128205128205128205128L;
                	    // e^(1 / 78)
                	    const double __e178 = 1.0129030479320018583185514777512983L;
                	    const double __c5 = __c4 + __e178;
                	    const double __c = __param._M_cb + __c5;
                	    const double __2cx = 2 * (2 * __m + __param._M_d);
                
                	    bool __reject = true;
                	    do
                	      {
                		const double __u = __c * __aurng();
                		const double __e = -std::log(1.0 - __aurng());
                
                		double __w = 0.0;
                
                		if (__u <= __c1)
                		  {
                		    const double __n = _M_nd(__urng);
                		    const double __y = -std::abs(__n) * __param._M_sm - 1;
                		    __x = std::floor(__y);
                		    __w = -__n * __n / 2;
                		    if (__x < -__m)
                		      continue;
                		  }
                		else if (__u <= __c2)
                		  {
                		    const double __n = _M_nd(__urng);
                		    const double __y = 1 + std::abs(__n) * __param._M_scx;
                		    __x = std::ceil(__y);
                		    __w = __y * (2 - __y) * __param._M_1cx;
                		    if (__x > __param._M_d)
                		      continue;
                		  }
                		else if (__u <= __c3)
                		  // NB: This case not in the book, nor in the Errata,
                		  // but should be ok...
                		  __x = -1;
                		else if (__u <= __c4)
                		  __x = 0;
                		else if (__u <= __c5)
                		  {
                		    __x = 1;
                		    // Only in the Errata, see libstdc++/83237.
                		    __w = __178;
                		  }
                		else
                		  {
                		    const double __v = -std::log(1.0 - __aurng());
                		    const double __y = __param._M_d
                				     + __v * __2cx / __param._M_d;
                		    __x = std::ceil(__y);
                		    __w = -__param._M_d * __param._M_1cx * (1 + __y / 2);
                		  }
                
                		__reject = (__w - __e - __x * __param._M_lm_thr
                			    > __param._M_lfm - std::lgamma(__x + __m + 1));
                
                		__reject |= __x + __m >= __thr;
                
                	      } while (__reject);
                
                	    return result_type(__x + __m + __naf);
                	  }
                	else
                #endif
                	  {
                	    _IntType     __x = 0;
                	    double __prod = 1.0;
                
                	    do
                	      {
                		__prod *= __aurng();
                		__x += 1;
                	      }
                	    while (__prod > __param._M_lm_thr);
                
                	    return __x - 1;
                	  }
                      }
                
                  template<typename _IntType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      poisson_distribution<_IntType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	// We could duplicate everything from operator()...
                	while (__f != __t)
                	  *__f++ = this->operator()(__urng, __param);
                      }
                
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const poisson_distribution<_IntType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<double>::max_digits10);
                
                      __os << __x.mean() << __space << __x._M_nd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       poisson_distribution<_IntType>& __x)
                    {
                      using param_type = typename poisson_distribution<_IntType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::skipws);
                
                      double __mean;
                      if (__is >> __mean >> __x._M_nd)
                	__x.param(param_type(__mean));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _IntType>
                    void
                    binomial_distribution<_IntType>::param_type::
                    _M_initialize()
                    {
                      const double __p12 = _M_p <= 0.5 ? _M_p : 1.0 - _M_p;
                
                      _M_easy = true;
                
                #if _GLIBCXX_USE_C99_MATH_TR1
                      if (_M_t * __p12 >= 8)
                	{
                	  _M_easy = false;
                	  const double __np = std::floor(_M_t * __p12);
                	  const double __pa = __np / _M_t;
                	  const double __1p = 1 - __pa;
                
                	  const double __pi_4 = 0.7853981633974483096156608458198757L;
                	  const double __d1x =
                	    std::sqrt(__np * __1p * std::log(32 * __np
                					     / (81 * __pi_4 * __1p)));
                	  _M_d1 = std::round(std::max<double>(1.0, __d1x));
                	  const double __d2x =
                	    std::sqrt(__np * __1p * std::log(32 * _M_t * __1p
                					     / (__pi_4 * __pa)));
                	  _M_d2 = std::round(std::max<double>(1.0, __d2x));
                
                	  // sqrt(pi / 2)
                	  const double __spi_2 = 1.2533141373155002512078826424055226L;
                	  _M_s1 = std::sqrt(__np * __1p) * (1 + _M_d1 / (4 * __np));
                	  _M_s2 = std::sqrt(__np * __1p) * (1 + _M_d2 / (4 * (_M_t * __1p)));
                	  _M_c = 2 * _M_d1 / __np;
                	  _M_a1 = std::exp(_M_c) * _M_s1 * __spi_2;
                	  const double __a12 = _M_a1 + _M_s2 * __spi_2;
                	  const double __s1s = _M_s1 * _M_s1;
                	  _M_a123 = __a12 + (std::exp(_M_d1 / (_M_t * __1p))
                			     * 2 * __s1s / _M_d1
                			     * std::exp(-_M_d1 * _M_d1 / (2 * __s1s)));
                	  const double __s2s = _M_s2 * _M_s2;
                	  _M_s = (_M_a123 + 2 * __s2s / _M_d2
                		  * std::exp(-_M_d2 * _M_d2 / (2 * __s2s)));
                	  _M_lf = (std::lgamma(__np + 1)
                		   + std::lgamma(_M_t - __np + 1));
                	  _M_lp1p = std::log(__pa / __1p);
                
                	  _M_q = -std::log(1 - (__p12 - __pa) / __1p);
                	}
                      else
                #endif
                	_M_q = -std::log(1 - __p12);
                    }
                
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename binomial_distribution<_IntType>::result_type
                      binomial_distribution<_IntType>::
                      _M_waiting(_UniformRandomNumberGenerator& __urng,
                		 _IntType __t, double __q)
                      {
                	_IntType __x = 0;
                	double __sum = 0.0;
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	do
                	  {
                	    if (__t == __x)
                	      return __x;
                	    const double __e = -std::log(1.0 - __aurng());
                	    __sum += __e / (__t - __x);
                	    __x += 1;
                	  }
                	while (__sum <= __q);
                
                	return __x - 1;
                      }
                
                  /**
                   * A rejection algorithm when t * p >= 8 and a simple waiting time
                   * method - the second in the referenced book - otherwise.
                   * NB: The former is available only if _GLIBCXX_USE_C99_MATH_TR1
                   * is defined.
                   *
                   * Reference:
                   * Devroye, L. Non-Uniform Random Variates Generation. Springer-Verlag,
                   * New York, 1986, Ch. X, Sect. 4 (+ Errata!).
                   */
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename binomial_distribution<_IntType>::result_type
                      binomial_distribution<_IntType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	result_type __ret;
                	const _IntType __t = __param.t();
                	const double __p = __param.p();
                	const double __p12 = __p <= 0.5 ? __p : 1.0 - __p;
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                #if _GLIBCXX_USE_C99_MATH_TR1
                	if (!__param._M_easy)
                	  {
                	    double __x;
                
                	    // See comments above...
                	    const double __naf =
                	      (1 - std::numeric_limits<double>::epsilon()) / 2;
                	    const double __thr =
                	      std::numeric_limits<_IntType>::max() + __naf;
                
                	    const double __np = std::floor(__t * __p12);
                
                	    // sqrt(pi / 2)
                	    const double __spi_2 = 1.2533141373155002512078826424055226L;
                	    const double __a1 = __param._M_a1;
                	    const double __a12 = __a1 + __param._M_s2 * __spi_2;
                	    const double __a123 = __param._M_a123;
                	    const double __s1s = __param._M_s1 * __param._M_s1;
                	    const double __s2s = __param._M_s2 * __param._M_s2;
                
                	    bool __reject;
                	    do
                	      {
                		const double __u = __param._M_s * __aurng();
                
                		double __v;
                
                		if (__u <= __a1)
                		  {
                		    const double __n = _M_nd(__urng);
                		    const double __y = __param._M_s1 * std::abs(__n);
                		    __reject = __y >= __param._M_d1;
                		    if (!__reject)
                		      {
                			const double __e = -std::log(1.0 - __aurng());
                			__x = std::floor(__y);
                			__v = -__e - __n * __n / 2 + __param._M_c;
                		      }
                		  }
                		else if (__u <= __a12)
                		  {
                		    const double __n = _M_nd(__urng);
                		    const double __y = __param._M_s2 * std::abs(__n);
                		    __reject = __y >= __param._M_d2;
                		    if (!__reject)
                		      {
                			const double __e = -std::log(1.0 - __aurng());
                			__x = std::floor(-__y);
                			__v = -__e - __n * __n / 2;
                		      }
                		  }
                		else if (__u <= __a123)
                		  {
                		    const double __e1 = -std::log(1.0 - __aurng());
                		    const double __e2 = -std::log(1.0 - __aurng());
                
                		    const double __y = __param._M_d1
                				     + 2 * __s1s * __e1 / __param._M_d1;
                		    __x = std::floor(__y);
                		    __v = (-__e2 + __param._M_d1 * (1 / (__t - __np)
                						    -__y / (2 * __s1s)));
                		    __reject = false;
                		  }
                		else
                		  {
                		    const double __e1 = -std::log(1.0 - __aurng());
                		    const double __e2 = -std::log(1.0 - __aurng());
                
                		    const double __y = __param._M_d2
                				     + 2 * __s2s * __e1 / __param._M_d2;
                		    __x = std::floor(-__y);
                		    __v = -__e2 - __param._M_d2 * __y / (2 * __s2s);
                		    __reject = false;
                		  }
                
                		__reject = __reject || __x < -__np || __x > __t - __np;
                		if (!__reject)
                		  {
                		    const double __lfx =
                		      std::lgamma(__np + __x + 1)
                		      + std::lgamma(__t - (__np + __x) + 1);
                		    __reject = __v > __param._M_lf - __lfx
                			     + __x * __param._M_lp1p;
                		  }
                
                		__reject |= __x + __np >= __thr;
                	      }
                	    while (__reject);
                
                	    __x += __np + __naf;
                
                	    const _IntType __z = _M_waiting(__urng, __t - _IntType(__x),
                					    __param._M_q);
                	    __ret = _IntType(__x) + __z;
                	  }
                	else
                #endif
                	  __ret = _M_waiting(__urng, __t, __param._M_q);
                
                	if (__p12 != __p)
                	  __ret = __t - __ret;
                	return __ret;
                      }
                
                  template<typename _IntType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      binomial_distribution<_IntType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	// We could duplicate everything from operator()...
                	while (__f != __t)
                	  *__f++ = this->operator()(__urng, __param);
                      }
                
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const binomial_distribution<_IntType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<double>::max_digits10);
                
                      __os << __x.t() << __space << __x.p()
                	   << __space << __x._M_nd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       binomial_distribution<_IntType>& __x)
                    {
                      using param_type = typename binomial_distribution<_IntType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _IntType __t;
                      double __p;
                      if (__is >> __t >> __p >> __x._M_nd)
                	__x.param(param_type(__t, __p));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::exponential_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	while (__f != __t)
                	  *__f++ = -std::log(result_type(1) - __aurng()) / __p.lambda();
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const exponential_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__os.widen(' '));
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.lambda();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       exponential_distribution<_RealType>& __x)
                    {
                      using param_type
                	= typename exponential_distribution<_RealType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __lambda;
                      if (__is >> __lambda)
                	__x.param(param_type(__lambda));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  /**
                   * Polar method due to Marsaglia.
                   *
                   * Devroye, L. Non-Uniform Random Variates Generation. Springer-Verlag,
                   * New York, 1986, Ch. V, Sect. 4.4.
                   */
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename normal_distribution<_RealType>::result_type
                      normal_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	result_type __ret;
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                
                	if (_M_saved_available)
                	  {
                	    _M_saved_available = false;
                	    __ret = _M_saved;
                	  }
                	else
                	  {
                	    result_type __x, __y, __r2;
                	    do
                	      {
                		__x = result_type(2.0) * __aurng() - 1.0;
                		__y = result_type(2.0) * __aurng() - 1.0;
                		__r2 = __x * __x + __y * __y;
                	      }
                	    while (__r2 > 1.0 || __r2 == 0.0);
                
                	    const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
                	    _M_saved = __x * __mult;
                	    _M_saved_available = true;
                	    __ret = __y * __mult;
                	  }
                
                	__ret = __ret * __param.stddev() + __param.mean();
                	return __ret;
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      normal_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                
                	if (__f == __t)
                	  return;
                
                	if (_M_saved_available)
                	  {
                	    _M_saved_available = false;
                	    *__f++ = _M_saved * __param.stddev() + __param.mean();
                
                	    if (__f == __t)
                	      return;
                	  }
                
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                
                	while (__f + 1 < __t)
                	  {
                	    result_type __x, __y, __r2;
                	    do
                	      {
                		__x = result_type(2.0) * __aurng() - 1.0;
                		__y = result_type(2.0) * __aurng() - 1.0;
                		__r2 = __x * __x + __y * __y;
                	      }
                	    while (__r2 > 1.0 || __r2 == 0.0);
                
                	    const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
                	    *__f++ = __y * __mult * __param.stddev() + __param.mean();
                	    *__f++ = __x * __mult * __param.stddev() + __param.mean();
                	  }
                
                	if (__f != __t)
                	  {
                	    result_type __x, __y, __r2;
                	    do
                	      {
                		__x = result_type(2.0) * __aurng() - 1.0;
                		__y = result_type(2.0) * __aurng() - 1.0;
                		__r2 = __x * __x + __y * __y;
                	      }
                	    while (__r2 > 1.0 || __r2 == 0.0);
                
                	    const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
                	    _M_saved = __x * __mult;
                	    _M_saved_available = true;
                	    *__f = __y * __mult * __param.stddev() + __param.mean();
                	  }
                      }
                
                  template<typename _RealType>
                    bool
                    operator==(const std::normal_distribution<_RealType>& __d1,
                	       const std::normal_distribution<_RealType>& __d2)
                    {
                      if (__d1._M_param == __d2._M_param
                	  && __d1._M_saved_available == __d2._M_saved_available)
                	return __d1._M_saved_available ? __d1._M_saved == __d2._M_saved : true;
                      else
                	return false;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const normal_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.mean() << __space << __x.stddev()
                	   << __space << __x._M_saved_available;
                      if (__x._M_saved_available)
                	__os << __space << __x._M_saved;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       normal_distribution<_RealType>& __x)
                    {
                      using param_type = typename normal_distribution<_RealType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      double __mean, __stddev;
                      bool __saved_avail;
                      if (__is >> __mean >> __stddev >> __saved_avail)
                	{
                	  if (!__saved_avail || (__is >> __x._M_saved))
                	    {
                	      __x._M_saved_available = __saved_avail;
                	      __x.param(param_type(__mean, __stddev));
                	    }
                	}
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      lognormal_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	  while (__f != __t)
                	    *__f++ = std::exp(__p.s() * _M_nd(__urng) + __p.m());
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const lognormal_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.m() << __space << __x.s()
                	   << __space << __x._M_nd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       lognormal_distribution<_RealType>& __x)
                    {
                      using param_type
                	= typename lognormal_distribution<_RealType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __m, __s;
                      if (__is >> __m >> __s >> __x._M_nd)
                	__x.param(param_type(__m, __s));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::chi_squared_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	while (__f != __t)
                	  *__f++ = 2 * _M_gd(__urng);
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::chi_squared_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const typename
                		      std::gamma_distribution<result_type>::param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	while (__f != __t)
                	  *__f++ = 2 * _M_gd(__urng, __p);
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const chi_squared_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.n() << __space << __x._M_gd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       chi_squared_distribution<_RealType>& __x)
                    {
                      using param_type
                	= typename chi_squared_distribution<_RealType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __n;
                      if (__is >> __n >> __x._M_gd)
                	__x.param(param_type(__n));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename cauchy_distribution<_RealType>::result_type
                      cauchy_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __p)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	_RealType __u;
                	do
                	  __u = __aurng();
                	while (__u == 0.5);
                
                	const _RealType __pi = 3.1415926535897932384626433832795029L;
                	return __p.a() + __p.b() * std::tan(__pi * __u);
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      cauchy_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	const _RealType __pi = 3.1415926535897932384626433832795029L;
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	while (__f != __t)
                	  {
                	    _RealType __u;
                	    do
                	      __u = __aurng();
                	    while (__u == 0.5);
                
                	    *__f++ = __p.a() + __p.b() * std::tan(__pi * __u);
                	  }
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const cauchy_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.a() << __space << __x.b();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       cauchy_distribution<_RealType>& __x)
                    {
                      using param_type = typename cauchy_distribution<_RealType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __a, __b;
                      if (__is >> __a >> __b)
                	__x.param(param_type(__a, __b));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::fisher_f_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	while (__f != __t)
                	  *__f++ = ((_M_gd_x(__urng) * n()) / (_M_gd_y(__urng) * m()));
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::fisher_f_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	typedef typename std::gamma_distribution<result_type>::param_type
                	  param_type;
                	param_type __p1(__p.m() / 2);
                	param_type __p2(__p.n() / 2);
                	while (__f != __t)
                	  *__f++ = ((_M_gd_x(__urng, __p1) * n())
                		    / (_M_gd_y(__urng, __p2) * m()));
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const fisher_f_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.m() << __space << __x.n()
                	   << __space << __x._M_gd_x << __space << __x._M_gd_y;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       fisher_f_distribution<_RealType>& __x)
                    {
                      using param_type
                	= typename fisher_f_distribution<_RealType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __m, __n;
                      if (__is >> __m >> __n >> __x._M_gd_x >> __x._M_gd_y)
                	__x.param(param_type(__m, __n));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::student_t_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	while (__f != __t)
                	  *__f++ = _M_nd(__urng) * std::sqrt(n() / _M_gd(__urng));
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::student_t_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	typename std::gamma_distribution<result_type>::param_type
                	  __p2(__p.n() / 2, 2);
                	while (__f != __t)
                	  *__f++ =  _M_nd(__urng) * std::sqrt(__p.n() / _M_gd(__urng, __p2));
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const student_t_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.n() << __space << __x._M_nd << __space << __x._M_gd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       student_t_distribution<_RealType>& __x)
                    {
                      using param_type
                	= typename student_t_distribution<_RealType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __n;
                      if (__is >> __n >> __x._M_nd >> __x._M_gd)
                	__x.param(param_type(__n));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    void
                    gamma_distribution<_RealType>::param_type::
                    _M_initialize()
                    {
                      _M_malpha = _M_alpha < 1.0 ? _M_alpha + _RealType(1.0) : _M_alpha;
                
                      const _RealType __a1 = _M_malpha - _RealType(1.0) / _RealType(3.0);
                      _M_a2 = _RealType(1.0) / std::sqrt(_RealType(9.0) * __a1);
                    }
                
                  /**
                   * Marsaglia, G. and Tsang, W. W.
                   * "A Simple Method for Generating Gamma Variables"
                   * ACM Transactions on Mathematical Software, 26, 3, 363-372, 2000.
                   */
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename gamma_distribution<_RealType>::result_type
                      gamma_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                
                	result_type __u, __v, __n;
                	const result_type __a1 = (__param._M_malpha
                				  - _RealType(1.0) / _RealType(3.0));
                
                	do
                	  {
                	    do
                	      {
                		__n = _M_nd(__urng);
                		__v = result_type(1.0) + __param._M_a2 * __n; 
                	      }
                	    while (__v <= 0.0);
                
                	    __v = __v * __v * __v;
                	    __u = __aurng();
                	  }
                	while (__u > result_type(1.0) - 0.0331 * __n * __n * __n * __n
                	       && (std::log(__u) > (0.5 * __n * __n + __a1
                				    * (1.0 - __v + std::log(__v)))));
                
                	if (__param.alpha() == __param._M_malpha)
                	  return __a1 * __v * __param.beta();
                	else
                	  {
                	    do
                	      __u = __aurng();
                	    while (__u == 0.0);
                	    
                	    return (std::pow(__u, result_type(1.0) / __param.alpha())
                		    * __a1 * __v * __param.beta());
                	  }
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      gamma_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                
                	result_type __u, __v, __n;
                	const result_type __a1 = (__param._M_malpha
                				  - _RealType(1.0) / _RealType(3.0));
                
                	if (__param.alpha() == __param._M_malpha)
                	  while (__f != __t)
                	    {
                	      do
                		{
                		  do
                		    {
                		      __n = _M_nd(__urng);
                		      __v = result_type(1.0) + __param._M_a2 * __n;
                		    }
                		  while (__v <= 0.0);
                
                		  __v = __v * __v * __v;
                		  __u = __aurng();
                		}
                	      while (__u > result_type(1.0) - 0.0331 * __n * __n * __n * __n
                		     && (std::log(__u) > (0.5 * __n * __n + __a1
                					  * (1.0 - __v + std::log(__v)))));
                
                	      *__f++ = __a1 * __v * __param.beta();
                	    }
                	else
                	  while (__f != __t)
                	    {
                	      do
                		{
                		  do
                		    {
                		      __n = _M_nd(__urng);
                		      __v = result_type(1.0) + __param._M_a2 * __n;
                		    }
                		  while (__v <= 0.0);
                
                		  __v = __v * __v * __v;
                		  __u = __aurng();
                		}
                	      while (__u > result_type(1.0) - 0.0331 * __n * __n * __n * __n
                		     && (std::log(__u) > (0.5 * __n * __n + __a1
                					  * (1.0 - __v + std::log(__v)))));
                
                	      do
                		__u = __aurng();
                	      while (__u == 0.0);
                
                	      *__f++ = (std::pow(__u, result_type(1.0) / __param.alpha())
                			* __a1 * __v * __param.beta());
                	    }
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const gamma_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.alpha() << __space << __x.beta()
                	   << __space << __x._M_nd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       gamma_distribution<_RealType>& __x)
                    {
                      using param_type = typename gamma_distribution<_RealType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __alpha_val, __beta_val;
                      if (__is >> __alpha_val >> __beta_val >> __x._M_nd)
                	__x.param(param_type(__alpha_val, __beta_val));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename weibull_distribution<_RealType>::result_type
                      weibull_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __p)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	return __p.b() * std::pow(-std::log(result_type(1) - __aurng()),
                				  result_type(1) / __p.a());
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      weibull_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	auto __inv_a = result_type(1) / __p.a();
                
                	while (__f != __t)
                	  *__f++ = __p.b() * std::pow(-std::log(result_type(1) - __aurng()),
                				      __inv_a);
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const weibull_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.a() << __space << __x.b();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       weibull_distribution<_RealType>& __x)
                    {
                      using param_type = typename weibull_distribution<_RealType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __a, __b;
                      if (__is >> __a >> __b)
                	__x.param(param_type(__a, __b));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename extreme_value_distribution<_RealType>::result_type
                      extreme_value_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __p)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	return __p.a() - __p.b() * std::log(-std::log(result_type(1)
                						      - __aurng()));
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      extreme_value_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                
                	while (__f != __t)
                	  *__f++ = __p.a() - __p.b() * std::log(-std::log(result_type(1)
                							  - __aurng()));
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const extreme_value_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.a() << __space << __x.b();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       extreme_value_distribution<_RealType>& __x)
                    {
                      using param_type
                	= typename extreme_value_distribution<_RealType>::param_type;
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __a, __b;
                      if (__is >> __a >> __b)
                	__x.param(param_type(__a, __b));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _IntType>
                    void
                    discrete_distribution<_IntType>::param_type::
                    _M_initialize()
                    {
                      if (_M_prob.size() < 2)
                	{
                	  _M_prob.clear();
                	  return;
                	}
                
                      const double __sum = std::accumulate(_M_prob.begin(),
                					   _M_prob.end(), 0.0);
                      __glibcxx_assert(__sum > 0);
                      // Now normalize the probabilites.
                      __detail::__normalize(_M_prob.begin(), _M_prob.end(), _M_prob.begin(),
                			    __sum);
                      // Accumulate partial sums.
                      _M_cp.reserve(_M_prob.size());
                      std::partial_sum(_M_prob.begin(), _M_prob.end(),
                		       std::back_inserter(_M_cp));
                      // Make sure the last cumulative probability is one.
                      _M_cp[_M_cp.size() - 1] = 1.0;
                    }
                
                  template<typename _IntType>
                    template<typename _Func>
                      discrete_distribution<_IntType>::param_type::
                      param_type(size_t __nw, double __xmin, double __xmax, _Func __fw)
                      : _M_prob(), _M_cp()
                      {
                	const size_t __n = __nw == 0 ? 1 : __nw;
                	const double __delta = (__xmax - __xmin) / __n;
                
                	_M_prob.reserve(__n);
                	for (size_t __k = 0; __k < __nw; ++__k)
                	  _M_prob.push_back(__fw(__xmin + __k * __delta + 0.5 * __delta));
                
                	_M_initialize();
                      }
                
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename discrete_distribution<_IntType>::result_type
                      discrete_distribution<_IntType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	if (__param._M_cp.empty())
                	  return result_type(0);
                
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	const double __p = __aurng();
                	auto __pos = std::lower_bound(__param._M_cp.begin(),
                				      __param._M_cp.end(), __p);
                
                	return __pos - __param._M_cp.begin();
                      }
                
                  template<typename _IntType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      discrete_distribution<_IntType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                
                	if (__param._M_cp.empty())
                	  {
                	    while (__f != __t)
                	      *__f++ = result_type(0);
                	    return;
                	  }
                
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	while (__f != __t)
                	  {
                	    const double __p = __aurng();
                	    auto __pos = std::lower_bound(__param._M_cp.begin(),
                					  __param._M_cp.end(), __p);
                
                	    *__f++ = __pos - __param._M_cp.begin();
                	  }
                      }
                
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const discrete_distribution<_IntType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<double>::max_digits10);
                
                      std::vector<double> __prob = __x.probabilities();
                      __os << __prob.size();
                      for (auto __dit = __prob.begin(); __dit != __prob.end(); ++__dit)
                	__os << __space << *__dit;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                namespace __detail
                {
                  template<typename _ValT, typename _CharT, typename _Traits>
                    basic_istream<_CharT, _Traits>&
                    __extract_params(basic_istream<_CharT, _Traits>& __is,
                		     vector<_ValT>& __vals, size_t __n)
                    {
                      __vals.reserve(__n);
                      while (__n--)
                	{
                	  _ValT __val;
                	  if (__is >> __val)
                	    __vals.push_back(__val);
                	  else
                	    break;
                	}
                      return __is;
                    }
                } // namespace __detail
                
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       discrete_distribution<_IntType>& __x)
                    {
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      size_t __n;
                      if (__is >> __n)
                	{
                	  std::vector<double> __prob_vec;
                	  if (__detail::__extract_params(__is, __prob_vec, __n))
                	    __x.param({__prob_vec.begin(), __prob_vec.end()});
                	}
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    void
                    piecewise_constant_distribution<_RealType>::param_type::
                    _M_initialize()
                    {
                      if (_M_int.size() < 2
                	  || (_M_int.size() == 2
                	      && _M_int[0] == _RealType(0)
                	      && _M_int[1] == _RealType(1)))
                	{
                	  _M_int.clear();
                	  _M_den.clear();
                	  return;
                	}
                
                      const double __sum = std::accumulate(_M_den.begin(),
                					   _M_den.end(), 0.0);
                      __glibcxx_assert(__sum > 0);
                
                      __detail::__normalize(_M_den.begin(), _M_den.end(), _M_den.begin(),
                			    __sum);
                
                      _M_cp.reserve(_M_den.size());
                      std::partial_sum(_M_den.begin(), _M_den.end(),
                		       std::back_inserter(_M_cp));
                
                      // Make sure the last cumulative probability is one.
                      _M_cp[_M_cp.size() - 1] = 1.0;
                
                      for (size_t __k = 0; __k < _M_den.size(); ++__k)
                	_M_den[__k] /= _M_int[__k + 1] - _M_int[__k];
                    }
                
                  template<typename _RealType>
                    template<typename _InputIteratorB, typename _InputIteratorW>
                      piecewise_constant_distribution<_RealType>::param_type::
                      param_type(_InputIteratorB __bbegin,
                		 _InputIteratorB __bend,
                		 _InputIteratorW __wbegin)
                      : _M_int(), _M_den(), _M_cp()
                      {
                	if (__bbegin != __bend)
                	  {
                	    for (;;)
                	      {
                		_M_int.push_back(*__bbegin);
                		++__bbegin;
                		if (__bbegin == __bend)
                		  break;
                
                		_M_den.push_back(*__wbegin);
                		++__wbegin;
                	      }
                	  }
                
                	_M_initialize();
                      }
                
                  template<typename _RealType>
                    template<typename _Func>
                      piecewise_constant_distribution<_RealType>::param_type::
                      param_type(initializer_list<_RealType> __bl, _Func __fw)
                      : _M_int(), _M_den(), _M_cp()
                      {
                	_M_int.reserve(__bl.size());
                	for (auto __biter = __bl.begin(); __biter != __bl.end(); ++__biter)
                	  _M_int.push_back(*__biter);
                
                	_M_den.reserve(_M_int.size() - 1);
                	for (size_t __k = 0; __k < _M_int.size() - 1; ++__k)
                	  _M_den.push_back(__fw(0.5 * (_M_int[__k + 1] + _M_int[__k])));
                
                	_M_initialize();
                      }
                
                  template<typename _RealType>
                    template<typename _Func>
                      piecewise_constant_distribution<_RealType>::param_type::
                      param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
                      : _M_int(), _M_den(), _M_cp()
                      {
                	const size_t __n = __nw == 0 ? 1 : __nw;
                	const _RealType __delta = (__xmax - __xmin) / __n;
                
                	_M_int.reserve(__n + 1);
                	for (size_t __k = 0; __k <= __nw; ++__k)
                	  _M_int.push_back(__xmin + __k * __delta);
                
                	_M_den.reserve(__n);
                	for (size_t __k = 0; __k < __nw; ++__k)
                	  _M_den.push_back(__fw(_M_int[__k] + 0.5 * __delta));
                
                	_M_initialize();
                      }
                
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename piecewise_constant_distribution<_RealType>::result_type
                      piecewise_constant_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	const double __p = __aurng();
                	if (__param._M_cp.empty())
                	  return __p;
                
                	auto __pos = std::lower_bound(__param._M_cp.begin(),
                				      __param._M_cp.end(), __p);
                	const size_t __i = __pos - __param._M_cp.begin();
                
                	const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;
                
                	return __param._M_int[__i] + (__p - __pref) / __param._M_den[__i];
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      piecewise_constant_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	if (__param._M_cp.empty())
                	  {
                	    while (__f != __t)
                	      *__f++ = __aurng();
                	    return;
                	  }
                
                	while (__f != __t)
                	  {
                	    const double __p = __aurng();
                
                	    auto __pos = std::lower_bound(__param._M_cp.begin(),
                					  __param._M_cp.end(), __p);
                	    const size_t __i = __pos - __param._M_cp.begin();
                
                	    const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;
                
                	    *__f++ = (__param._M_int[__i]
                		      + (__p - __pref) / __param._M_den[__i]);
                	  }
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const piecewise_constant_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      std::vector<_RealType> __int = __x.intervals();
                      __os << __int.size() - 1;
                
                      for (auto __xit = __int.begin(); __xit != __int.end(); ++__xit)
                	__os << __space << *__xit;
                
                      std::vector<double> __den = __x.densities();
                      for (auto __dit = __den.begin(); __dit != __den.end(); ++__dit)
                	__os << __space << *__dit;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       piecewise_constant_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      size_t __n;
                      if (__is >> __n)
                	{
                	  std::vector<_RealType> __int_vec;
                	  if (__detail::__extract_params(__is, __int_vec, __n + 1))
                	    {
                	      std::vector<double> __den_vec;
                	      if (__detail::__extract_params(__is, __den_vec, __n))
                		{
                		  __x.param({ __int_vec.begin(), __int_vec.end(),
                			      __den_vec.begin() });
                		}
                	    }
                	}
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    void
                    piecewise_linear_distribution<_RealType>::param_type::
                    _M_initialize()
                    {
                      if (_M_int.size() < 2
                	  || (_M_int.size() == 2
                	      && _M_int[0] == _RealType(0)
                	      && _M_int[1] == _RealType(1)
                	      && _M_den[0] == _M_den[1]))
                	{
                	  _M_int.clear();
                	  _M_den.clear();
                	  return;
                	}
                
                      double __sum = 0.0;
                      _M_cp.reserve(_M_int.size() - 1);
                      _M_m.reserve(_M_int.size() - 1);
                      for (size_t __k = 0; __k < _M_int.size() - 1; ++__k)
                	{
                	  const _RealType __delta = _M_int[__k + 1] - _M_int[__k];
                	  __sum += 0.5 * (_M_den[__k + 1] + _M_den[__k]) * __delta;
                	  _M_cp.push_back(__sum);
                	  _M_m.push_back((_M_den[__k + 1] - _M_den[__k]) / __delta);
                	}
                      __glibcxx_assert(__sum > 0);
                
                      //  Now normalize the densities...
                      __detail::__normalize(_M_den.begin(), _M_den.end(), _M_den.begin(),
                			    __sum);
                      //  ... and partial sums... 
                      __detail::__normalize(_M_cp.begin(), _M_cp.end(), _M_cp.begin(), __sum);
                      //  ... and slopes.
                      __detail::__normalize(_M_m.begin(), _M_m.end(), _M_m.begin(), __sum);
                
                      //  Make sure the last cumulative probablility is one.
                      _M_cp[_M_cp.size() - 1] = 1.0;
                     }
                
                  template<typename _RealType>
                    template<typename _InputIteratorB, typename _InputIteratorW>
                      piecewise_linear_distribution<_RealType>::param_type::
                      param_type(_InputIteratorB __bbegin,
                		 _InputIteratorB __bend,
                		 _InputIteratorW __wbegin)
                      : _M_int(), _M_den(), _M_cp(), _M_m()
                      {
                	for (; __bbegin != __bend; ++__bbegin, ++__wbegin)
                	  {
                	    _M_int.push_back(*__bbegin);
                	    _M_den.push_back(*__wbegin);
                	  }
                
                	_M_initialize();
                      }
                
                  template<typename _RealType>
                    template<typename _Func>
                      piecewise_linear_distribution<_RealType>::param_type::
                      param_type(initializer_list<_RealType> __bl, _Func __fw)
                      : _M_int(), _M_den(), _M_cp(), _M_m()
                      {
                	_M_int.reserve(__bl.size());
                	_M_den.reserve(__bl.size());
                	for (auto __biter = __bl.begin(); __biter != __bl.end(); ++__biter)
                	  {
                	    _M_int.push_back(*__biter);
                	    _M_den.push_back(__fw(*__biter));
                	  }
                
                	_M_initialize();
                      }
                
                  template<typename _RealType>
                    template<typename _Func>
                      piecewise_linear_distribution<_RealType>::param_type::
                      param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
                      : _M_int(), _M_den(), _M_cp(), _M_m()
                      {
                	const size_t __n = __nw == 0 ? 1 : __nw;
                	const _RealType __delta = (__xmax - __xmin) / __n;
                
                	_M_int.reserve(__n + 1);
                	_M_den.reserve(__n + 1);
                	for (size_t __k = 0; __k <= __nw; ++__k)
                	  {
                	    _M_int.push_back(__xmin + __k * __delta);
                	    _M_den.push_back(__fw(_M_int[__k] + __delta));
                	  }
                
                	_M_initialize();
                      }
                
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename piecewise_linear_distribution<_RealType>::result_type
                      piecewise_linear_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	const double __p = __aurng();
                	if (__param._M_cp.empty())
                	  return __p;
                
                	auto __pos = std::lower_bound(__param._M_cp.begin(),
                				      __param._M_cp.end(), __p);
                	const size_t __i = __pos - __param._M_cp.begin();
                
                	const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;
                
                	const double __a = 0.5 * __param._M_m[__i];
                	const double __b = __param._M_den[__i];
                	const double __cm = __p - __pref;
                
                	_RealType __x = __param._M_int[__i];
                	if (__a == 0)
                	  __x += __cm / __b;
                	else
                	  {
                	    const double __d = __b * __b + 4.0 * __a * __cm;
                	    __x += 0.5 * (std::sqrt(__d) - __b) / __a;
                          }
                
                        return __x;
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      piecewise_linear_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	// We could duplicate everything from operator()...
                	while (__f != __t)
                	  *__f++ = this->operator()(__urng, __param);
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const piecewise_linear_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_ostream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      std::vector<_RealType> __int = __x.intervals();
                      __os << __int.size() - 1;
                
                      for (auto __xit = __int.begin(); __xit != __int.end(); ++__xit)
                	__os << __space << *__xit;
                
                      std::vector<double> __den = __x.densities();
                      for (auto __dit = __den.begin(); __dit != __den.end(); ++__dit)
                	__os << __space << *__dit;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       piecewise_linear_distribution<_RealType>& __x)
                    {
                      using __ios_base = typename basic_istream<_CharT, _Traits>::ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      size_t __n;
                      if (__is >> __n)
                	{
                	  vector<_RealType> __int_vec;
                	  if (__detail::__extract_params(__is, __int_vec, __n + 1))
                	    {
                	      vector<double> __den_vec;
                	      if (__detail::__extract_params(__is, __den_vec, __n + 1))
                		{
                		  __x.param({ __int_vec.begin(), __int_vec.end(),
                			      __den_vec.begin() });
                		}
                	    }
                	}
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _IntType, typename>
                    seed_seq::seed_seq(std::initializer_list<_IntType> __il)
                    {
                      _M_v.reserve(__il.size());
                      for (auto __iter = __il.begin(); __iter != __il.end(); ++__iter)
                	_M_v.push_back(__detail::__mod<result_type,
                		       __detail::_Shift<result_type, 32>::__value>(*__iter));
                    }
                
                  template<typename _InputIterator>
                    seed_seq::seed_seq(_InputIterator __begin, _InputIterator __end)
                    {
                      if _GLIBCXX17_CONSTEXPR (__is_random_access_iter<_InputIterator>::value)
                	_M_v.reserve(std::distance(__begin, __end));
                
                      for (_InputIterator __iter = __begin; __iter != __end; ++__iter)
                	_M_v.push_back(__detail::__mod<result_type,
                		       __detail::_Shift<result_type, 32>::__value>(*__iter));
                    }
                
                  template<typename _RandomAccessIterator>
                    void
                    seed_seq::generate(_RandomAccessIterator __begin,
                		       _RandomAccessIterator __end)
                    {
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                        _Type;
                
                      if (__begin == __end)
                	return;
                
                      std::fill(__begin, __end, _Type(0x8b8b8b8bu));
                
                      const size_t __n = __end - __begin;
                      const size_t __s = _M_v.size();
                      const size_t __t = (__n >= 623) ? 11
                		       : (__n >=  68) ? 7
                		       : (__n >=  39) ? 5
                		       : (__n >=   7) ? 3
                		       : (__n - 1) / 2;
                      const size_t __p = (__n - __t) / 2;
                      const size_t __q = __p + __t;
                      const size_t __m = std::max(size_t(__s + 1), __n);
                
                #ifndef __UINT32_TYPE__
                      struct _Up
                      {
                	_Up(uint_least32_t v) : _M_v(v & 0xffffffffu) { }
                
                	operator uint_least32_t() const { return _M_v; }
                
                	uint_least32_t _M_v;
                      };
                      using uint32_t = _Up;
                #endif
                
                      // k == 0, every element in [begin,end) equals 0x8b8b8b8bu
                	{
                	  uint32_t __r1 = 1371501266u;
                	  uint32_t __r2 = __r1 + __s;
                	  __begin[__p] += __r1;
                	  __begin[__q] = (uint32_t)__begin[__q] + __r2;
                	  __begin[0] = __r2;
                	}
                
                      for (size_t __k = 1; __k <= __s; ++__k)
                	{
                	  const size_t __kn = __k % __n;
                	  const size_t __kpn = (__k + __p) % __n;
                	  const size_t __kqn = (__k + __q) % __n;
                	  uint32_t __arg = (__begin[__kn]
                			    ^ __begin[__kpn]
                			    ^ __begin[(__k - 1) % __n]);
                	  uint32_t __r1 = 1664525u * (__arg ^ (__arg >> 27));
                	  uint32_t __r2 = __r1 + (uint32_t)__kn + _M_v[__k - 1];
                	  __begin[__kpn] = (uint32_t)__begin[__kpn] + __r1;
                	  __begin[__kqn] = (uint32_t)__begin[__kqn] + __r2;
                	  __begin[__kn] = __r2;
                	}
                
                      for (size_t __k = __s + 1; __k < __m; ++__k)
                	{
                	  const size_t __kn = __k % __n;
                	  const size_t __kpn = (__k + __p) % __n;
                	  const size_t __kqn = (__k + __q) % __n;
                	  uint32_t __arg = (__begin[__kn]
                				 ^ __begin[__kpn]
                				 ^ __begin[(__k - 1) % __n]);
                	  uint32_t __r1 = 1664525u * (__arg ^ (__arg >> 27));
                	  uint32_t __r2 = __r1 + (uint32_t)__kn;
                	  __begin[__kpn] = (uint32_t)__begin[__kpn] + __r1;
                	  __begin[__kqn] = (uint32_t)__begin[__kqn] + __r2;
                	  __begin[__kn] = __r2;
                	}
                
                      for (size_t __k = __m; __k < __m + __n; ++__k)
                	{
                	  const size_t __kn = __k % __n;
                	  const size_t __kpn = (__k + __p) % __n;
                	  const size_t __kqn = (__k + __q) % __n;
                	  uint32_t __arg = (__begin[__kn]
                			    + __begin[__kpn]
                			    + __begin[(__k - 1) % __n]);
                	  uint32_t __r3 = 1566083941u * (__arg ^ (__arg >> 27));
                	  uint32_t __r4 = __r3 - __kn;
                	  __begin[__kpn] ^= __r3;
                	  __begin[__kqn] ^= __r4;
                	  __begin[__kn] = __r4;
                	}
                    }
                
                  template<typename _RealType, size_t __bits,
                	   typename _UniformRandomNumberGenerator>
                    _RealType
       96722 ->     generate_canonical(_UniformRandomNumberGenerator& __urng)
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument must be a floating point type");
                
                      const size_t __b
                	= std::min(static_cast<size_t>(std::numeric_limits<_RealType>::digits),
                                   __bits);
                      const long double __r = static_cast<long double>(__urng.max())
                			    - static_cast<long double>(__urng.min()) + 1.0L;
                      const size_t __log2r = std::log(__r) / std::log(2.0L);
                      const size_t __m = std::max<size_t>(1UL,
                					  (__b + __log2r - 1UL) / __log2r);
                      _RealType __ret;
                      _RealType __sum = _RealType(0);
                      _RealType __tmp = _RealType(1);
                      for (size_t __k = __m; __k != 0; --__k)
                	{
                	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
                	  __tmp *= __r;
                	}
                      __ret = __sum / __tmp;
                      if (__builtin_expect(__ret >= _RealType(1), 0))
                	{
                #if _GLIBCXX_USE_C99_MATH_TR1
                	  __ret = std::nextafter(_RealType(1), _RealType(0));
                #else
                	  __ret = _RealType(1)
                	    - std::numeric_limits<_RealType>::epsilon() / _RealType(2);
                #endif
                	}
                      return __ret;
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif


Top 10 Lines:

     Line      Count

     3349      96722
      397        311

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

    97033   Total number of line executions
 48516.50   Average executions per line


*** File /home/sunny/Desktop/HPC_Project/src/serial/barnes_hut.cpp:
                #include "barnes_hut.h"
                #include <cmath>
                #include <functional>
                
           1 -> BarnesHutSolver::BarnesHutSolver(double G, double theta, double softening)
                    : G_(G), theta_(theta), theta_sq_(theta * theta), softening_(softening),
                      softening_sq_(softening * softening), interaction_count_(0) {}
                
           1 -> void BarnesHutSolver::build_tree(const std::vector<Particle> &particles) {
                  tree_.build(particles);
                }
                
                void BarnesHutSolver::compute_force_on_particle(Particle &particle,
      510000 ->                                                 const OctreeNode *node) {
                  if (!node || node->get_type() == OctreeNode::Type::EMPTY) {
                    return;
                  }
                
                  if (node->get_type() == OctreeNode::Type::LEAF) {
                    // Leaf node - compute direct force if not same particle
                    const Particle *other = node->get_particle();
                    if (other->id == particle.id) {
                      return; // Skip self-interaction
                    }
                
                    Vector3D r = other->position - particle.position;
                    double dist_sq = r.magnitude_sq() + softening_sq_;
                    double dist = sqrt(dist_sq);
                    double dist_cubed = dist_sq * dist;
                
                    double force_factor = G_ * other->mass / dist_cubed;
                    particle.acceleration += r * force_factor;
                
                    interaction_count_++;
                    return;
                  }
                
                  // Internal node - check MAC criterion
                  if (node->can_approximate(particle.position, theta_)) {
                    // Use center of mass approximation
                    Vector3D r = node->get_center_of_mass() - particle.position;
                    double dist_sq = r.magnitude_sq() + softening_sq_;
                    double dist = sqrt(dist_sq);
                    double dist_cubed = dist_sq * dist;
                
                    double force_factor = G_ * node->get_total_mass() / dist_cubed;
                    particle.acceleration += r * force_factor;
                
                    interaction_count_++;
                  } else {
                    // Recurse into children
                    for (int i = 0; i < 8; ++i) {
                      compute_force_on_particle(particle, node->get_child(i));
                    }
                  }
                }
                
           1 -> void BarnesHutSolver::compute_forces(std::vector<Particle> &particles) {
                  interaction_count_ = 0;
                
                  // Reset accelerations
                  for (auto &p : particles) {
                    p.reset_acceleration();
                  }
                
                  // Compute force on each particle using tree traversal
                  for (auto &p : particles) {
                    compute_force_on_particle(p, tree_.get_root());
                  }
                }
                
          50 -> void BarnesHutSolver::integrate(std::vector<Particle> &particles, double dt) {
                  // Leapfrog integration (Kick-Drift-Kick)
                  double half_dt = 0.5 * dt;
                
                  for (auto &p : particles) {
                    // Kick: update velocity by half step
                    p.velocity += p.acceleration * half_dt;
                
                    // Drift: update position by full step
                    p.position += p.velocity * dt;
                  }
                
                  // Rebuild tree at new positions
                  build_tree(particles);
                
                  // Compute new forces
                  compute_forces(particles);
                
                  for (auto &p : particles) {
                    // Kick: update velocity by half step
                    p.velocity += p.acceleration * half_dt;
                  }
                }
                
          50 -> void BarnesHutSolver::step(std::vector<Particle> &particles, double dt) {
                  integrate(particles, dt);
                }
                
                double BarnesHutSolver::compute_kinetic_energy(
       ##### ->     const std::vector<Particle> &particles) const {
                  double KE = 0.0;
                  for (const auto &p : particles) {
                    KE += p.kinetic_energy();
                  }
                  return KE;
                }
                
                double BarnesHutSolver::compute_potential_energy(
           2 ->     const std::vector<Particle> &particles) {
                  // Use tree-based approximation for potential energy
                  double PE = 0.0;
                
                  // Build tree if not already built
                  if (!tree_.get_root()) {
                    tree_.build(particles);
                  }
                
                  // For each particle, traverse tree (similar to force computation)
                  for (const auto &p : particles) {
                    std::function<double(const OctreeNode *)> calc_pe =
                        [&](const OctreeNode *node) -> double {
                      if (!node || node->get_type() == OctreeNode::Type::EMPTY) {
                        return 0.0;
                      }
                
                      if (node->get_type() == OctreeNode::Type::LEAF) {
                        const Particle *other = node->get_particle();
                        if (other->id == p.id)
                          return 0.0;
                
                        Vector3D r = other->position - p.position;
                        double dist = sqrt(r.magnitude_sq() + softening_sq_);
                        return -G_ * p.mass * other->mass / dist;
                      }
                
                      if (node->can_approximate(p.position, theta_)) {
                        Vector3D r = node->get_center_of_mass() - p.position;
                        double dist = sqrt(r.magnitude_sq() + softening_sq_);
                        return -G_ * p.mass * node->get_total_mass() / dist;
                      }
                
                      double sum = 0.0;
                      for (int i = 0; i < 8; ++i) {
                        sum += calc_pe(node->get_child(i));
                      }
                      return sum;
                    };
                
                    PE += calc_pe(tree_.get_root());
                  }
                
                  // Divide by 2 to correct for double counting
                  return PE * 0.5;
                }
                
                double
           2 -> BarnesHutSolver::compute_total_energy(const std::vector<Particle> &particles) {
                  return compute_kinetic_energy(particles) +
                         compute_potential_energy(particles);
                }


Top 10 Lines:

     Line      Count

       14     510000
      288      20000
       72         50
       96         50
      110          2
      158          2
        5          1
        9          1
       58          1

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

   530107   Total number of line executions
 58900.78   Average executions per line


*** File /usr/include/c++/13/bits/std_function.h:
                // Implementation of std::function -*- C++ -*-
                
                // Copyright (C) 2004-2023 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/bits/std_function.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{functional}
                 */
                
                #ifndef _GLIBCXX_STD_FUNCTION_H
                #define _GLIBCXX_STD_FUNCTION_H 1
                
                #pragma GCC system_header
                
                #if __cplusplus < 201103L
                # include <bits/c++0x_warning.h>
                #else
                
                #include <new>                // placement new
                #include <typeinfo>           // typeid
                #include <bits/invoke.h>      // __invoke_r
                #include <bits/refwrap.h>     // ref wrapper, _Maybe_unary_or_binary_function
                #include <bits/functexcept.h> // __throw_bad_function_call
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @brief Exception class thrown when class template function's
                   *  operator() is called with an empty target.
                   *  @ingroup exceptions
                   */
                  class bad_function_call : public std::exception
                  {
                  public:
                    virtual ~bad_function_call() noexcept;
                
                    const char* what() const noexcept;
                  };
                
                  /**
                   *  Trait identifying "location-invariant" types, meaning that the
                   *  address of the object (or any of its members) will not escape.
                   *  Trivially copyable types are location-invariant and users can
                   *  specialize this trait for other types.
                   */
                  template<typename _Tp>
                    struct __is_location_invariant
                    : is_trivially_copyable<_Tp>::type
                    { };
                
                  class _Undefined_class;
                
                  union _Nocopy_types
                  {
                    void*       _M_object;
                    const void* _M_const_object;
                    void (*_M_function_pointer)();
                    void (_Undefined_class::*_M_member_pointer)();
                  };
                
                  union [[gnu::may_alias]] _Any_data
                  {
                    void*       _M_access()       noexcept { return &_M_pod_data[0]; }
                    const void* _M_access() const noexcept { return &_M_pod_data[0]; }
                
                    template<typename _Tp>
                      _Tp&
                      _M_access() noexcept
                      { return *static_cast<_Tp*>(_M_access()); }
                
                    template<typename _Tp>
                      const _Tp&
                      _M_access() const noexcept
                      { return *static_cast<const _Tp*>(_M_access()); }
                
                    _Nocopy_types _M_unused;
                    char _M_pod_data[sizeof(_Nocopy_types)];
                  };
                
                  enum _Manager_operation
                  {
                    __get_type_info,
                    __get_functor_ptr,
                    __clone_functor,
                    __destroy_functor
                  };
                
                  template<typename _Signature>
                    class function;
                
                  /// Base class of all polymorphic function object wrappers.
                  class _Function_base
                  {
                  public:
                    static const size_t _M_max_size = sizeof(_Nocopy_types);
                    static const size_t _M_max_align = __alignof__(_Nocopy_types);
                
                    template<typename _Functor>
                      class _Base_manager
                      {
                      protected:
                	static const bool __stored_locally =
                	(__is_location_invariant<_Functor>::value
                	 && sizeof(_Functor) <= _M_max_size
                	 && __alignof__(_Functor) <= _M_max_align
                	 && (_M_max_align % __alignof__(_Functor) == 0));
                
                	using _Local_storage = integral_constant<bool, __stored_locally>;
                
                	// Retrieve a pointer to the function object
                	static _Functor*
                	_M_get_pointer(const _Any_data& __source) noexcept
                	{
                	  if _GLIBCXX17_CONSTEXPR (__stored_locally)
                	    {
                	      const _Functor& __f = __source._M_access<_Functor>();
                	      return const_cast<_Functor*>(std::__addressof(__f));
                	    }
                	  else // have stored a pointer
                	    return __source._M_access<_Functor*>();
                	}
                
                      private:
                	// Construct a location-invariant function object that fits within
                	// an _Any_data structure.
                	template<typename _Fn>
                	  static void
                	  _M_create(_Any_data& __dest, _Fn&& __f, true_type)
                	  {
                	    ::new (__dest._M_access()) _Functor(std::forward<_Fn>(__f));
                	  }
                
                	// Construct a function object on the heap and store a pointer.
                	template<typename _Fn>
                	  static void
                	  _M_create(_Any_data& __dest, _Fn&& __f, false_type)
                	  {
                	    __dest._M_access<_Functor*>()
                	      = new _Functor(std::forward<_Fn>(__f));
                	  }
                
                	// Destroy an object stored in the internal buffer.
                	static void
                	_M_destroy(_Any_data& __victim, true_type)
                	{
                	  __victim._M_access<_Functor>().~_Functor();
                	}
                
                	// Destroy an object located on the heap.
                	static void
                	_M_destroy(_Any_data& __victim, false_type)
                	{
                	  delete __victim._M_access<_Functor*>();
                	}
                
                      public:
                	static bool
                	_M_manager(_Any_data& __dest, const _Any_data& __source,
                		   _Manager_operation __op)
                	{
                	  switch (__op)
                	    {
                	    case __get_type_info:
                #if __cpp_rtti
                	      __dest._M_access<const type_info*>() = &typeid(_Functor);
                #else
                	      __dest._M_access<const type_info*>() = nullptr;
                #endif
                	      break;
                
                	    case __get_functor_ptr:
                	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
                	      break;
                
                	    case __clone_functor:
                	      _M_init_functor(__dest,
                		  *const_cast<const _Functor*>(_M_get_pointer(__source)));
                	      break;
                
                	    case __destroy_functor:
                	      _M_destroy(__dest, _Local_storage());
                	      break;
                	    }
                	  return false;
                	}
                
                	template<typename _Fn>
                	  static void
                	  _M_init_functor(_Any_data& __functor, _Fn&& __f)
                	  noexcept(__and_<_Local_storage,
                			  is_nothrow_constructible<_Functor, _Fn>>::value)
                	  {
                	    _M_create(__functor, std::forward<_Fn>(__f), _Local_storage());
                	  }
                
                	template<typename _Signature>
                	  static bool
                	  _M_not_empty_function(const function<_Signature>& __f) noexcept
                	  { return static_cast<bool>(__f); }
                
                	template<typename _Tp>
                	  static bool
                	  _M_not_empty_function(_Tp* __fp) noexcept
                	  { return __fp != nullptr; }
                
                	template<typename _Class, typename _Tp>
                	  static bool
                	  _M_not_empty_function(_Tp _Class::* __mp) noexcept
                	  { return __mp != nullptr; }
                
                	template<typename _Tp>
                	  static bool
                	  _M_not_empty_function(const _Tp&) noexcept
                	  { return true; }
                      };
                
                    _Function_base() = default;
                
                    ~_Function_base()
                    {
                      if (_M_manager)
                	_M_manager(_M_functor, _M_functor, __destroy_functor);
                    }
                
                    bool _M_empty() const { return !_M_manager; }
                
                    using _Manager_type
                      = bool (*)(_Any_data&, const _Any_data&, _Manager_operation);
                
                    _Any_data     _M_functor{};
                    _Manager_type _M_manager{};
                  };
                
                  template<typename _Signature, typename _Functor>
                    class _Function_handler;
                
                  template<typename _Res, typename _Functor, typename... _ArgTypes>
                    class _Function_handler<_Res(_ArgTypes...), _Functor>
                    : public _Function_base::_Base_manager<_Functor>
                    {
                      using _Base = _Function_base::_Base_manager<_Functor>;
                
                    public:
                      static bool
       20000 ->       _M_manager(_Any_data& __dest, const _Any_data& __source,
                		 _Manager_operation __op)
                      {
                	switch (__op)
                	  {
                #if __cpp_rtti
                	  case __get_type_info:
                	    __dest._M_access<const type_info*>() = &typeid(_Functor);
                	    break;
                #endif
                	  case __get_functor_ptr:
                	    __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
                	    break;
                
                	  default:
                	    _Base::_M_manager(__dest, __source, __op);
                	  }
                	return false;
                      }
                
                      static _Res
         400 ->       _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
                      {
                	return std::__invoke_r<_Res>(*_Base::_M_get_pointer(__functor),
                				     std::forward<_ArgTypes>(__args)...);
                      }
                
                      template<typename _Fn>
                	static constexpr bool
                	_S_nothrow_init() noexcept
                	{
                	  return __and_<typename _Base::_Local_storage,
                			is_nothrow_constructible<_Functor, _Fn>>::value;
                	}
                    };
                
                  // Specialization for invalid types
                  template<>
                    class _Function_handler<void, void>
                    {
                    public:
                      static bool
                      _M_manager(_Any_data&, const _Any_data&, _Manager_operation)
                      { return false; }
                    };
                
                  // Avoids instantiating ill-formed specializations of _Function_handler
                  // in std::function<_Signature>::target<_Functor>().
                  // e.g. _Function_handler<Sig, void()> and _Function_handler<Sig, void>
                  // would be ill-formed.
                  template<typename _Signature, typename _Functor,
                	   bool __valid = is_object<_Functor>::value>
                    struct _Target_handler
                    : _Function_handler<_Signature, typename remove_cv<_Functor>::type>
                    { };
                
                  template<typename _Signature, typename _Functor>
                    struct _Target_handler<_Signature, _Functor, false>
                    : _Function_handler<void, void>
                    { };
                
                  /**
                   *  @brief Polymorphic function wrapper.
                   *  @ingroup functors
                   *  @since C++11
                   */
                  template<typename _Res, typename... _ArgTypes>
                    class function<_Res(_ArgTypes...)>
                    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
                      private _Function_base
                    {
                      // Equivalent to std::decay_t except that it produces an invalid type
                      // if the decayed type is the current specialization of std::function.
                      template<typename _Func,
                	       bool _Self = is_same<__remove_cvref_t<_Func>, function>::value>
                	using _Decay_t
                	  = typename __enable_if_t<!_Self, decay<_Func>>::type;
                
                      template<typename _Func,
                	       typename _DFunc = _Decay_t<_Func>,
                	       typename _Res2 = __invoke_result<_DFunc&, _ArgTypes...>>
                	struct _Callable
                	: __is_invocable_impl<_Res2, _Res>::type
                	{ };
                
                      template<typename _Cond, typename _Tp = void>
                	using _Requires = __enable_if_t<_Cond::value, _Tp>;
                
                      template<typename _Functor>
                	using _Handler
                	  = _Function_handler<_Res(_ArgTypes...), __decay_t<_Functor>>;
                
                    public:
                      typedef _Res result_type;
                
                      // [3.7.2.1] construct/copy/destroy
                
                      /**
                       *  @brief Default construct creates an empty function call wrapper.
                       *  @post `!(bool)*this`
                       */
                      function() noexcept
                      : _Function_base() { }
                
                      /**
                       *  @brief Creates an empty function call wrapper.
                       *  @post @c !(bool)*this
                       */
                      function(nullptr_t) noexcept
                      : _Function_base() { }
                
                      /**
                       *  @brief %Function copy constructor.
                       *  @param __x A %function object with identical call signature.
                       *  @post `bool(*this) == bool(__x)`
                       *
                       *  The newly-created %function contains a copy of the target of
                       *  `__x` (if it has one).
                       */
                      function(const function& __x)
                      : _Function_base()
                      {
                	if (static_cast<bool>(__x))
                	  {
                	    __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
                	    _M_invoker = __x._M_invoker;
                	    _M_manager = __x._M_manager;
                	  }
                      }
                
                      /**
                       *  @brief %Function move constructor.
                       *  @param __x A %function object rvalue with identical call signature.
                       *
                       *  The newly-created %function contains the target of `__x`
                       *  (if it has one).
                       */
                      function(function&& __x) noexcept
                      : _Function_base(), _M_invoker(__x._M_invoker)
                      {
                	if (static_cast<bool>(__x))
                	  {
                	    _M_functor = __x._M_functor;
                	    _M_manager = __x._M_manager;
                	    __x._M_manager = nullptr;
                	    __x._M_invoker = nullptr;
                	  }
                      }
                
                      /**
                       *  @brief Builds a %function that targets a copy of the incoming
                       *  function object.
                       *  @param __f A %function object that is callable with parameters of
                       *  type `ArgTypes...` and returns a value convertible to `Res`.
                       *
                       *  The newly-created %function object will target a copy of
                       *  `__f`. If `__f` is `reference_wrapper<F>`, then this function
                       *  object will contain a reference to the function object `__f.get()`.
                       *  If `__f` is a null function pointer, null pointer-to-member, or
                       *  empty `std::function`, the newly-created object will be empty.
                       *
                       *  If `__f` is a non-null function pointer or an object of type
                       *  `reference_wrapper<F>`, this function will not throw.
                       */
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2774. std::function construction vs assignment
                      template<typename _Functor,
                	       typename _Constraints = _Requires<_Callable<_Functor>>>
                	function(_Functor&& __f)
                	noexcept(_Handler<_Functor>::template _S_nothrow_init<_Functor>())
                	: _Function_base()
                	{
                	  static_assert(is_copy_constructible<__decay_t<_Functor>>::value,
                	      "std::function target must be copy-constructible");
                	  static_assert(is_constructible<__decay_t<_Functor>, _Functor>::value,
                	      "std::function target must be constructible from the "
                	      "constructor argument");
                
                	  using _My_handler = _Handler<_Functor>;
                
                	  if (_My_handler::_M_not_empty_function(__f))
                	    {
                	      _My_handler::_M_init_functor(_M_functor,
                					   std::forward<_Functor>(__f));
                	      _M_invoker = &_My_handler::_M_invoke;
                	      _M_manager = &_My_handler::_M_manager;
                	    }
                	}
                
                      /**
                       *  @brief Function assignment operator.
                       *  @param __x A %function with identical call signature.
                       *  @post `(bool)*this == (bool)x`
                       *  @returns `*this`
                       *
                       *  The target of `__x` is copied to `*this`. If `__x` has no
                       *  target, then `*this` will be empty.
                       *
                       *  If `__x` targets a function pointer or a reference to a function
                       *  object, then this operation will not throw an exception.
                       */
                      function&
                      operator=(const function& __x)
                      {
                	function(__x).swap(*this);
                	return *this;
                      }
                
                      /**
                       *  @brief Function move-assignment operator.
                       *  @param __x A %function rvalue with identical call signature.
                       *  @returns `*this`
                       *
                       *  The target of `__x` is moved to `*this`. If `__x` has no
                       *  target, then `*this` will be empty.
                       *
                       *  If `__x` targets a function pointer or a reference to a function
                       *  object, then this operation will not throw an exception.
                       */
                      function&
                      operator=(function&& __x) noexcept
                      {
                	function(std::move(__x)).swap(*this);
                	return *this;
                      }
                
                      /**
                       *  @brief Function assignment to empty.
                       *  @post `!(bool)*this`
                       *  @returns `*this`
                       *
                       *  The target of `*this` is deallocated, leaving it empty.
                       */
                      function&
                      operator=(nullptr_t) noexcept
                      {
                	if (_M_manager)
                	  {
                	    _M_manager(_M_functor, _M_functor, __destroy_functor);
                	    _M_manager = nullptr;
                	    _M_invoker = nullptr;
                	  }
                	return *this;
                      }
                
                      /**
                       *  @brief Function assignment to a new target.
                       *  @param __f  A function object that is callable with parameters of
                       *              type  `_ArgTypes...` and returns a value convertible
                       *              to `_Res`.
                       *  @return `*this`
                       *  @since C++11
                       *
                       *  This function object wrapper will target a copy of `__f`. If `__f`
                       *  is `reference_wrapper<F>`, then this function object will contain
                       *  a reference to the function object `__f.get()`. If `__f` is a null
                       *  function pointer or null pointer-to-member, this object will be
                       *  empty.
                       *
                       *  If `__f` is a non-null function pointer or an object of type
                       *  `reference_wrapper<F>`, this function will not throw.
                       */
                      template<typename _Functor>
                	_Requires<_Callable<_Functor>, function&>
                	operator=(_Functor&& __f)
                	noexcept(_Handler<_Functor>::template _S_nothrow_init<_Functor>())
                	{
                	  function(std::forward<_Functor>(__f)).swap(*this);
                	  return *this;
                	}
                
                      /// @overload
                      template<typename _Functor>
                	function&
                	operator=(reference_wrapper<_Functor> __f) noexcept
                	{
                	  function(__f).swap(*this);
                	  return *this;
                	}
                
                      // [3.7.2.2] function modifiers
                
                      /**
                       *  @brief Swap the targets of two %function objects.
                       *  @param __x A %function with identical call signature.
                       *
                       *  Swap the targets of `this` function object and `__f`.
                       *  This function will not throw exceptions.
                       */
                      void swap(function& __x) noexcept
                      {
                	std::swap(_M_functor, __x._M_functor);
                	std::swap(_M_manager, __x._M_manager);
                	std::swap(_M_invoker, __x._M_invoker);
                      }
                
                      // [3.7.2.3] function capacity
                
                      /**
                       *  @brief Determine if the %function wrapper has a target.
                       *
                       *  @return `true` when this function object contains a target,
                       *  or `false` when it is empty.
                       *
                       *  This function will not throw exceptions.
                       */
                      explicit operator bool() const noexcept
                      { return !_M_empty(); }
                
                      // [3.7.2.4] function invocation
                
                      /**
                       *  @brief Invokes the function targeted by `*this`.
                       *  @returns the result of the target.
                       *  @throws `bad_function_call` when `!(bool)*this`
                       *
                       *  The function call operator invokes the target function object
                       *  stored by `this`.
                       */
                      _Res
                      operator()(_ArgTypes... __args) const
                      {
                	if (_M_empty())
                	  __throw_bad_function_call();
                	return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
                      }
                
                #if __cpp_rtti
                      // [3.7.2.5] function target access
                      /**
                       *  @brief Determine the type of the target of this function object
                       *  wrapper.
                       *
                       *  @returns the type identifier of the target function object, or
                       *  `typeid(void)` if `!(bool)*this`.
                       *
                       *  This function will not throw exceptions.
                       */
                      const type_info&
                      target_type() const noexcept
                      {
                	if (_M_manager)
                	  {
                	    _Any_data __typeinfo_result;
                	    _M_manager(__typeinfo_result, _M_functor, __get_type_info);
                	    if (auto __ti =  __typeinfo_result._M_access<const type_info*>())
                	      return *__ti;
                	  }
                	return typeid(void);
                      }
                #endif
                
                      /**
                       *  @brief Access the stored target function object.
                       *
                       *  @return Returns a pointer to the stored target function object,
                       *  if `typeid(_Functor).equals(target_type())`; otherwise, a null
                       *  pointer.
                       *
                       * This function does not throw exceptions.
                       *
                       * @{
                       */
                      template<typename _Functor>
                	_Functor*
                	target() noexcept
                	{
                	  const function* __const_this = this;
                	  const _Functor* __func = __const_this->template target<_Functor>();
                	  // If is_function_v<_Functor> is true then const_cast<_Functor*>
                	  // would be ill-formed, so use *const_cast<_Functor**> instead.
                	  return *const_cast<_Functor**>(&__func);
                	}
                
                      template<typename _Functor>
                	const _Functor*
                	target() const noexcept
                	{
                	  if _GLIBCXX17_CONSTEXPR (is_object<_Functor>::value)
                	    {
                	      // For C++11 and C++14 if-constexpr is not used above, so
                	      // _Target_handler avoids ill-formed _Function_handler types.
                	      using _Handler = _Target_handler<_Res(_ArgTypes...), _Functor>;
                
                	      if (_M_manager == &_Handler::_M_manager
                #if __cpp_rtti
                		  || (_M_manager && typeid(_Functor) == target_type())
                #endif
                		 )
                		{
                		  _Any_data __ptr;
                		  _M_manager(__ptr, _M_functor, __get_functor_ptr);
                		  return __ptr._M_access<const _Functor*>();
                		}
                	    }
                	  return nullptr;
                	}
                      /// @}
                
                    private:
                      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
                      _Invoker_type _M_invoker = nullptr;
                    };
                
                #if __cpp_deduction_guides >= 201606
                  template<typename>
                    struct __function_guide_helper
                    { };
                
                  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
                    struct __function_guide_helper<
                      _Res (_Tp::*) (_Args...) noexcept(_Nx)
                    >
                    { using type = _Res(_Args...); };
                
                  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
                    struct __function_guide_helper<
                      _Res (_Tp::*) (_Args...) & noexcept(_Nx)
                    >
                    { using type = _Res(_Args...); };
                
                  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
                    struct __function_guide_helper<
                      _Res (_Tp::*) (_Args...) const noexcept(_Nx)
                    >
                    { using type = _Res(_Args...); };
                
                  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
                    struct __function_guide_helper<
                      _Res (_Tp::*) (_Args...) const & noexcept(_Nx)
                    >
                    { using type = _Res(_Args...); };
                
                #if __cpp_static_call_operator >= 202207L && __cpp_concepts >= 202002L
                  template<typename _StaticCallOp>
                    struct __function_guide_static_helper
                    { };
                
                  template<typename _Res, bool _Nx, typename... _Args>
                    struct __function_guide_static_helper<_Res (*) (_Args...) noexcept(_Nx)>
                    { using type = _Res(_Args...); };
                
                  template<typename _Fn, typename _Op>
                    using __function_guide_t = typename __conditional_t<
                      requires (_Fn& __f) { (void) __f.operator(); },
                      __function_guide_static_helper<_Op>,
                      __function_guide_helper<_Op>>::type;
                #else
                  template<typename _Fn, typename _Op>
                    using __function_guide_t = typename __function_guide_helper<_Op>::type;
                #endif
                
                  template<typename _Res, typename... _ArgTypes>
                    function(_Res(*)(_ArgTypes...)) -> function<_Res(_ArgTypes...)>;
                
                  template<typename _Fn, typename _Signature
                	     = __function_guide_t<_Fn, decltype(&_Fn::operator())>>
                    function(_Fn) -> function<_Signature>;
                #endif
                
                  // [20.7.15.2.6] null pointer comparisons
                
                  /**
                   *  @brief Test whether a polymorphic function object wrapper is empty.
                   *  @returns `true` if the wrapper has no target, `false` otherwise
                   *
                   *  This function will not throw exceptions.
                   */
                  template<typename _Res, typename... _Args>
                    inline bool
                    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
                    { return !static_cast<bool>(__f); }
                
                #if __cpp_impl_three_way_comparison < 201907L
                  /// @overload
                  template<typename _Res, typename... _Args>
                    inline bool
                    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
                    { return !static_cast<bool>(__f); }
                
                  /**
                   *  @brief Test whether a polymorphic function object wrapper is non-empty.
                   *  @returns `false` if the wrapper has no target, `true` otherwise
                   *
                   *  This function will not throw exceptions.
                   */
                  template<typename _Res, typename... _Args>
                    inline bool
                    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
                    { return static_cast<bool>(__f); }
                
                  /// @overload
                  template<typename _Res, typename... _Args>
                    inline bool
                    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
                    { return static_cast<bool>(__f); }
                #endif
                
                  // [20.7.15.2.7] specialized algorithms
                
                  /**
                   *  @brief Swap the targets of two polymorphic function object wrappers.
                   *
                   *  This function will not throw exceptions.
                   */
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2062. Effect contradictions w/o no-throw guarantee of std::function swaps
                  template<typename _Res, typename... _Args>
                    inline void
                    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y) noexcept
                    { __x.swap(__y); }
                
                #if __cplusplus >= 201703L
                  namespace __detail::__variant
                  {
                    template<typename> struct _Never_valueless_alt; // see <variant>
                
                    // Provide the strong exception-safety guarantee when emplacing a
                    // function into a variant.
                    template<typename _Signature>
                      struct _Never_valueless_alt<std::function<_Signature>>
                      : std::true_type
                      { };
                  }  // namespace __detail::__variant
                #endif // C++17
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                #endif // _GLIBCXX_STD_FUNCTION_H


Top 10 Lines:

     Line      Count

      267      20000
      288        400

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

    20400   Total number of line executions
 10200.00   Average executions per line


*** File /home/sunny/Desktop/HPC_Project/src/serial/octree.cpp:
                #include "octree.h"
                #include <algorithm>
                #include <cmath>
                #include <functional>
                #include <limits>
                
                // BoundingBox implementation
     1971971 -> BoundingBox::BoundingBox(const Vector3D &min_, const Vector3D &max_)
                    : min(min_), max(max_) {
                  center = (min + max) * 0.5;
                  size = (max - min).magnitude();
                }
                
       ##### -> bool BoundingBox::contains(const Vector3D &point) const {
                  return point.x >= min.x && point.x <= max.x && point.y >= min.y &&
                         point.y <= max.y && point.z >= min.z && point.z <= max.z;
                }
                
       ##### -> int BoundingBox::get_octant(const Vector3D &point) const {
                  int octant = 0;
                  if (point.x >= center.x)
                    octant |= 1;
                  if (point.y >= center.y)
                    octant |= 2;
                  if (point.z >= center.z)
                    octant |= 4;
                  return octant;
                }
                
     1971920 -> BoundingBox BoundingBox::get_child_box(int octant) const {
                  Vector3D child_min = min;
                  Vector3D child_max = center;
                
                  if (octant & 1) {
                    child_min.x = center.x;
                    child_max.x = max.x;
                  }
                  if (octant & 2) {
                    child_min.y = center.y;
                    child_max.y = max.y;
                  }
                  if (octant & 4) {
                    child_min.z = center.z;
                    child_max.z = max.z;
                  }
                
                  return BoundingBox(child_min, child_max);
                }
                
                // OctreeNode implementation
     1971971 -> OctreeNode::OctreeNode(const BoundingBox &bounds)
                    : type_(Type::EMPTY), bounds_(bounds), particle_(nullptr), total_mass_(0.0),
                      particle_count_(0) {
                  for (auto &child : children_) {
                    child = nullptr;
                  }
                }
                
      510000 -> void OctreeNode::subdivide() {
                  for (int i = 0; i < 8; ++i) {
                    BoundingBox child_bounds = bounds_.get_child_box(i);
                    children_[i] = std::make_unique<OctreeNode>(child_bounds);
                  }
                }
                
       ##### -> void OctreeNode::insert(const Particle &particle, int depth) {
                  if (depth > BarnesHut::MAX_DEPTH) {
                    // Max depth reached, just accumulate mass
                    if (type_ == Type::EMPTY) {
                      type_ = Type::LEAF;
                      particle_ = &particle;
                    }
                    particle_count_++;
                    return;
                  }
                
                  switch (type_) {
                  case Type::EMPTY:
                    // First particle in this node
                    type_ = Type::LEAF;
                    particle_ = &particle;
                    particle_count_ = 1;
                    break;
                
                  case Type::LEAF: {
                    // Need to subdivide
                    const Particle *existing = particle_;
                    type_ = Type::INTERNAL;
                    particle_ = nullptr;
                    subdivide();
                
                    // Re-insert existing particle
                    int octant = bounds_.get_octant(existing->position);
                    children_[octant]->insert(*existing, depth + 1);
                
                    // Insert new particle
                    octant = bounds_.get_octant(particle.position);
                    children_[octant]->insert(particle, depth + 1);
                    particle_count_ = 2;
                    break;
                  }
                
                  case Type::INTERNAL: {
                    // Insert into appropriate child
                    int octant = bounds_.get_octant(particle.position);
                    children_[octant]->insert(particle, depth + 1);
                    particle_count_++;
                    break;
                  }
                  }
                }
                
          51 -> void OctreeNode::compute_mass_distribution() {
                  switch (type_) {
                  case Type::EMPTY:
                    total_mass_ = 0.0;
                    center_of_mass_ = Vector3D();
                    break;
                
                  case Type::LEAF:
                    total_mass_ = particle_->mass;
                    center_of_mass_ = particle_->position;
                    break;
                
                  case Type::INTERNAL:
                    total_mass_ = 0.0;
                    center_of_mass_ = Vector3D();
                
                    for (auto &child : children_) {
                      if (child && child->type_ != Type::EMPTY) {
                        child->compute_mass_distribution();
                        center_of_mass_ += child->center_of_mass_ * child->total_mass_;
                        total_mass_ += child->total_mass_;
                      }
                    }
                
                    if (total_mass_ > 0.0) {
                      center_of_mass_ /= total_mass_;
                    }
                    break;
                  }
                }
                
  1058930495 -> bool OctreeNode::can_approximate(const Vector3D &point, double theta) const {
                  // Multipole acceptance criterion (MAC)
                  // If s/d < theta, we can approximate this node as a single mass
                  // s = size of node, d = distance from point to center of mass
                
                  double d_sq = (point - center_of_mass_).magnitude_sq();
                  double s_sq = bounds_.size * bounds_.size;
                
                  return s_sq < theta * theta * d_sq;
                }
                
                // Octree implementation
           1 -> Octree::Octree(double domain_size) : domain_size_(domain_size) {}
                
                BoundingBox
          51 -> Octree::compute_bounding_box(const std::vector<Particle> &particles) const {
                  if (particles.empty()) {
                    return BoundingBox(Vector3D(),
                                       Vector3D(domain_size_, domain_size_, domain_size_));
                  }
                
                  Vector3D min_pos(std::numeric_limits<double>::max(),
                                   std::numeric_limits<double>::max(),
                                   std::numeric_limits<double>::max());
                  Vector3D max_pos(std::numeric_limits<double>::lowest(),
                                   std::numeric_limits<double>::lowest(),
                                   std::numeric_limits<double>::lowest());
                
                  for (const auto &p : particles) {
                    min_pos.x = std::min(min_pos.x, p.position.x);
                    min_pos.y = std::min(min_pos.y, p.position.y);
                    min_pos.z = std::min(min_pos.z, p.position.z);
                    max_pos.x = std::max(max_pos.x, p.position.x);
                    max_pos.y = std::max(max_pos.y, p.position.y);
                    max_pos.z = std::max(max_pos.z, p.position.z);
                  }
                
                  // Make it a cube (octree requires cubic cells)
                  double size = std::max(
                      {max_pos.x - min_pos.x, max_pos.y - min_pos.y, max_pos.z - min_pos.z});
                  size *= 1.01; // Small margin
                
                  Vector3D center = (min_pos + max_pos) * 0.5;
                  Vector3D half_size(size * 0.5, size * 0.5, size * 0.5);
                
                  return BoundingBox(center - half_size, center + half_size);
                }
                
          51 -> void Octree::build(const std::vector<Particle> &particles) {
                  clear();
                
                  BoundingBox bounds = compute_bounding_box(particles);
                  root_ = std::make_unique<OctreeNode>(bounds);
                
                  for (const auto &p : particles) {
                    root_->insert(p);
                  }
                
                  root_->compute_mass_distribution();
                }
                
       ##### -> void Octree::clear() { root_.reset(); }
                
       ##### -> int Octree::get_node_count() const {
                  if (!root_)
                    return 0;
                
                  std::function<int(const OctreeNode *)> count =
                      [&](const OctreeNode *node) -> int {
                    if (!node || node->get_type() == OctreeNode::Type::EMPTY)
                      return 0;
                
                    int c = 1;
                    if (node->get_type() == OctreeNode::Type::INTERNAL) {
                      for (int i = 0; i < 8; ++i) {
                        c += count(node->get_child(i));
                      }
                    }
                    return c;
                  };
                
                  return count(root_.get());
                }
                
       ##### -> int Octree::get_max_depth() const {
                  if (!root_)
                    return 0;
                
                  std::function<int(const OctreeNode *, int)> depth =
                      [&](const OctreeNode *node, int d) -> int {
                    if (!node || node->get_type() != OctreeNode::Type::INTERNAL)
                      return d;
                
                    int max_d = d;
                    for (int i = 0; i < 8; ++i) {
                      max_d = std::max(max_d, depth(node->get_child(i), d + 1));
                    }
       ##### ->     return max_d;
                  };
                
                  return depth(root_.get(), 0);
                }


Top 10 Lines:

     Line      Count

      144 1058930495
        8    1971971
       51    1971971
       30    1971920
       59     510000
      113         51
      159         51
      192         51
      156          1

Execution Summary:

       16   Executable lines in this file
       16   Lines executed
   100.00   Percent of the file executed

1065356511   Total number of line executions
66584781.94   Average executions per line
